---
title: "Statische Karten"
author: "Nico Hahn"
date: "2 8 2019"
output: html_document
---

```{r, echo=FALSE, include=FALSE}
library(spData)
library(spDataLarge)
library(tmap)
library(sf)
library(colourpicker)
library(stringr)
library(viridis)
library(maps)
library(raster)
# load shapefiles for bavaria
bavaria <- st_read("datasets/bavaria.shp")
# keep some data
bavaria <- bavaria[, c(2, 3, 14, 38, 42, 49, 58, 71, 88, 112, 132)]
# nicer colnames
colnames(bavaria) <- c(
  "Ort", "Art", "BIP je Einwohner", "Durchschnittsalter",
  "Siedlungsdichte", "Arbeitslosenquote",
  "Beschaeftigtenquote", "Haushaltseinkommen",
  "Studierende", "Bevoelkerungsentwicklung", "geometry"
)
# turn values into numeric
bavaria$`BIP je Einwohner` <- as.numeric(as.character(
  bavaria$`BIP je Einwohner`
))
bavaria$Durchschnittsalter <- as.numeric(as.character(
  bavaria$Durchschnittsalter
))
bavaria$Siedlungsdichte <- as.numeric(as.character(
  bavaria$Siedlungsdichte
))
bavaria$Arbeitslosenquote <- as.numeric(as.character(
  bavaria$Arbeitslosenquote
))
bavaria$Beschaeftigtenquote <- as.numeric(as.character(
  bavaria$Beschaeftigtenquote
))
bavaria$Haushaltseinkommen <- as.numeric(as.character(
  bavaria$Haushaltseinkommen
))
bavaria$Studierende <- as.numeric(as.character(
  bavaria$Studierende
))
bavaria$Bevoelkerungsentwicklung <- as.numeric(
  as.character(bavaria$Bevoelkerungsentwicklung)
)
# load europe elevation raster
europe_raster <- raster("datasets/elevation1x1_new.tif")
# load europe shapefiles
europe_shape <- read_sf("datasets/ne_50m_admin_0_countries/ne_50m_admin_0_countries.shp")
europe_shape <- europe_shape[europe_shape$CONTINENT == "Europe",]
# cities above populaiton of 1 million
cities <- world.cities[world.cities$pop >= 1000000, ]
cities <- cities %>% st_as_sf(coords = c("long", "lat"), crs = 4326) %>%
  st_cast("POINT")
cities <- st_intersection(cities, st_union(europe_shape))
europe_shape <- st_cast(europe_shape, "MULTILINESTRING")
```


# Statische Karten
Am häufigsten werden geographische Daten mit Hilfe von statischen Karten dargestellt, die als `.png` oder `.pdf` Datei abgespeichert werden können. Ursprünglich konnten in R nur auf diese Art Daten visualisiert werden, doch durch die Entwicklung neuer Pakete, allen voran **sp**, wurden neue Möglichkeiten zur Darstellung dieser Daten geschaffen. Doch trotz neuen Methoden wie interaktiven Karten sind statische Karten auch heute noch das Steckenpferd der Datenvisualisierung in R.

## tmap
Die schnellste Möglichkeit zur Erstellung von Karten in R ist die Verwendung der `plot()` Funktion, mit der Vektor- und Rasterdaten simplistisch dargestellt werden können. Durch die Verwendung mehrerer Argumente, wie beispielsweise `col`, können die Graphiken gestylt werden, um mehr Informationen zu übermitteln. Eine weitere Möglichkeit stellt das Paket **grid** dar, mit dem mehr Kontrolle möglich ist.
Ein Paket, dass speziell zur Illustration von Geodaten entwickelt wurde, ist **tmap**. Dieses hat eine kompakte Syntax, ähnlich der von **ggplot2**. Des weiteren können statische Karten durch die Verwendung des Befehls `tmap_mode()` schnell in interaktive Karten umgewandelt werden und umgekehrt. Außerdem werden die meißten geographischen Klassen als input akzeptiert, im Vergleich zu anderen Paketen, auch `raster` Daten.

Wie bereits erwähnt ähnelt die Syntax von **tmap** der von **ggplot2**. Dies beinhaltet eine strikte Trennung zwischen den Daten und der Ästhetik. Zu Beginn wird `tm_shape()` ein Datensatz übergeben, gefolgt von ein oder mehreren Ebene, die die Art der Darstellung definieren. Dazu zählen beispielhaft `tm_fill()` und `tm_dots()` um Daten als Polygone beziehungsweise Punkte zu plotten. 
```{r, eval=FALSE}
tm_shape(bavaria) +
  tm_fill()

tm_shape(bavaria) +
  tm_borders()

tm_shape(bavaria) +
  tm_polygons()
```
```{r chunk1, echo=FALSE, fig.cap="Einfaches Beispiel", fig.align="center"}
bav_1 <- tm_shape(bavaria) +
  tm_fill()

bav_2 <- tm_shape(bavaria) +
  tm_borders()

bav_3 <- tm_shape(bavaria) +
  tm_polygons()
tmap_arrange(bav_1, bav_2, bav_3, ncol = 3)
```

Das hier übergebene Objekt `bavaria` hat die Klasse `sf` und stellt die einzelnen Städte und Landkreis Bayerns dar. `tm_fill()` füllt die einzelnen Polygone, wodurch ein gefüllter Grundriss Bayerns entsteht . `tm_borders()` zeichnet die Grenzen der einzelnen Polygone und `tm_polygons()` vereint die beiden Funktionen und stellt beides gleichzeitig dar. Durch den `+` Operator können weitere Ebene hinzugefügt werden, mit denen verschiedene Arten von geographischen Daten visualisiert werden können.

## Karten Objekte
Mit **tmap** können Objekte nicht nur geplotted werden, sondern auch als Objekte der Klasse `"tmap"`.
```{r}
map_europe <- tm_shape(europe_raster) + tm_raster()
class(map_europe)

```
Das gespeicherte Objekte kann so einfach erweitert werden, oder zu einem späteren Zeitpunkt in der Konsole aufgerufen werden. Des weiteren können zu dem Objekt weitere Ebenen mit `tm_shape()` hinzugefügt werden, wodurch mehrere Karten zu einer kombiniert werden können.
Im folgenden Codebeispiel wird auf dem obigen Code, der ein Höhenraster von Europa darstellt, aufgebaut. Dabei werden zunächst die Grenzlinien der einzelnen Staaten hinzugefügt, gefolgt von allen Städten mit über einer Millionen Einwohnern.
```{r}
map_europe2 <- map_europe +
        tm_shape(europe_shape) + tm_lines(alpha = 0.3)
map_europe3 <- map_europe2  +
        tm_shape(cities) + tm_dots(size = 0.3)
```
```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.align="center", fig.cap="Verwendung mehrerer Ebenen"}
map_europe3
```
Durch das speichern der einzelnen Karten als Objekte können diese auch mit Hilfe der Funktion `tmap_arrange()` neben- oder übereinander dargestellt werden. Grafik \ref{fig::chunk1} wurde durch diesen Befehl erstellt.
```{r, eval=FALSE}
tmap_arrange(bav_1, bav_2, bav_3, ncol = 3)
```
Der Nutzer ist nicht limitiert in der Anzahl an Ebenen, die er hinzufügen kann. Dabei sollte jedoch beachtet werden, dass bei zu viel Informationen der Betrachter schnell überfordert sein kann.

## Ästhetik
Bei den bisherigen Plots wurden die Standard Einstellungen von **tmap** verwendet. Zur Gestaltung visuell ansprechender Karten, können diese überschrieben werden. Dabei gibt es zwei Möglichkeiten:
    - Konstante Ästhetik
    - Ästhetik die sich mit Variablenausprägung ändert
Im Vergleich zu **ggplot2** wird keine Helferfunktion (`aes()`) verwendet, um die Gestaltung der Karte zu individualisieren. Stattdessen werden die Argumente direkt übergeben. Zu den am häufigsten verwendeten Argumenten zählt die Füllfarbe (`col`), die Transparenz (`alpha`), die Strichstärke (`lwd`) und die Linienart (`lty`).

```{r, fig.align="center",fig.cap="Verwendung verschiedener Argumente"}
bav4 <- tm_shape(bavaria) + tm_fill(col = "darkgreen")
bav5 <- tm_shape(bavaria) + tm_fill(col = "darkgreen", alpha = 0.5)
bav6 <- tm_shape(bavaria) + tm_polygons(col = "darkgreen", border.col = "orange")
bav7 <- tm_shape(bavaria) + tm_borders(lwd = 2)
bav8 <- tm_shape(bavaria) + tm_borders(lty = 4)
bav9 <- tm_shape(bavaria) + tm_polygons(col = "#E2E2E2", border.alpha = 0.5, lwd = 3)
tmap_arrange(bav4, bav5, bav6, bav7, bav8, bav9, ncol = 3)
```

Ein weiterer Unterschied zu **ggplot2** besteht darin, dass die Variablen Namen als character übergeben werden müssen und der `$` Operator somit nicht verwendet werden kann.
```{r, error=TRUE}
tm_shape(bavaria) + tm_polygons(col = bavaria$Bevoelkerungsentwicklung)
```

Die gewünschte Grafik wird mit folgendem Code erreicht:
```{r, eval=FALSE}
tm_shape(bavaria) + tm_polygons(col = "Bevoelkerungsentwicklung",
                                midpoint = 0)
```
```{r, fig.align="center",fig.cap="Bevölkerungsentwicklung in Bayern von 2011 bis 2015", echo=FALSE}
tm_shape(bavaria) + tm_polygons(col = "Bevoelkerungsentwicklung",
                                midpoint = 0) +
  tm_layout(legend.outside = TRUE)
```

Das `midpoint` Argument wird hier verwendet, um den Wert 0 als natürlichen Mittelpunkt zu verwenden. In der resultierenden Karte ist zu erkennen, dass die Bevölkerung im Norden Bayerns zurückgeht, während vor allem um München herum die Bevölkerung starkt ansteigt. 
```{r, echo=FALSE, fig.align="center", fig.cap = "Karte in base R"}
pal <- colorRampPalette(c("orange", "green"))
bavaria$order <- findInterval(bavaria$Bevoelkerungsentwicklung, sort(bavaria$Bevoelkerungsentwicklung))
plot(st_geometry(bavaria), col = pal(nrow(bavaria))[bavaria$order])  # works

```

Am Beispiel der letzten Karten ist zu sehen, dass **tmap** automatisch eine Farbpalette und Intervalle auswählt. Um andere Intervalle zu verwenden kann entweder dem `breaks` Argument manuelle Grenzen übergeben werden oder mit `n` die Anzahl der bins festgelegt werden.
```{r, eval = FALSE}
tm_shape(bavaria) + tm_polygons(col = "Durchschnittsalter")
tm_shape(bavaria) + tm_polygons(col = "Durchschnittsalter",
                                       breaks = c(40, 42, 46, 54))
tm_shape(bavaria) + tm_polygons(col = "Durchschnittsalter", n = 3)
```
```{r, fig.align="center",fig.cap="Illustration des breaks und n Arguments", echo = FALSE}
ba1 <- tm_shape(bavaria) + tm_polygons(col = "Durchschnittsalter")
ba2 <- tm_shape(bavaria) + tm_polygons(col = "Durchschnittsalter",
                                       breaks = c(40, 42, 46, 54))
ba3 <- tm_shape(bavaria) + tm_polygons(col = "Durchschnittsalter", n = 3)
tmap_arrange(ba1, ba2, ba3, ncol = 3)
```
## Karten in Karten