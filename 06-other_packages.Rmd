---
title: "5-other_packages"
author: "Nico Hahn"
date: "21 August 2019"
output: html_document
---

```{r, include=FALSE}
library(sf)
library(ggplot2)
library(ggspatial)
library(mapdeck)
library(mapview)
library(leaflet)
library(plotly)
library(rgeos)
library(rgdal)
library(raster)
library(dplyr)
library(grid)
library(RColorBrewer)
library(scico)
library(lattice)
library(leafpop)
library(KernSmooth)
library(htmltools)
library(htmlwidgets)
set_token("pk.eyJ1Ijoibmljb2hhaG4iLCJhIjoiY2p2YzU4ZWNiMWY4ZTQ2cGZsZHB5cDJzZiJ9.Sg3fJKvEhfkuhKx7aBBjZA")
honey <- read_sf("datasets/honey.shp")
colnames(honey)[3:8] <- c("Number_of_colonies", "Yield_per_colony",
                          "Total_production", "Stocks","Price_per_lb",
                          "Value_of_production"
                          )
honey2008 <- honey[honey$year == 2008, ]
honey2008_multi <- st_cast(honey2008, "MULTILINESTRING")
bavaria <- st_read("datasets/bavaria.shp")
# nicer colnames
colnames(bavaria) <- c(
  "Ort", "Art", "BIP je Einwohner", "Durchschnittsalter",
  "Siedlungsdichte", "Arbeitslosenquote",
  "Beschaeftigtenquote", "Haushaltseinkommen",
  "Studierende", "Bevoelkerungsentwicklung", "geometry"
)
# turn values into numeric
bavaria$`BIP je Einwohner` <- as.numeric(as.character(
  bavaria$`BIP je Einwohner`
))
bavaria$Durchschnittsalter <- as.numeric(as.character(
  bavaria$Durchschnittsalter
))
bavaria$Siedlungsdichte <- as.numeric(as.character(
  bavaria$Siedlungsdichte
))
bavaria$Arbeitslosenquote <- as.numeric(as.character(
  bavaria$Arbeitslosenquote
))
bavaria$Beschaeftigtenquote <- as.numeric(as.character(
  bavaria$Beschaeftigtenquote
))
bavaria$Haushaltseinkommen <- as.numeric(as.character(
  bavaria$Haushaltseinkommen
))
bavaria$Studierende <- as.numeric(as.character(
  bavaria$Studierende
))
bavaria$Bevoelkerungsentwicklung <- as.numeric(
  as.character(bavaria$Bevoelkerungsentwicklung)
)
bavaria$Ort <- as.character(bavaria$Ort)
reg <- st_read("datasets/regbez_ex.kml")
# intersections
bavaria <- st_intersection(bavaria, reg)
# more data
autobahn <- st_read("datasets/autobahn.kml")
airports <- st_read("datasets/airports.kml")
europe_raster <- raster("datasets/elevation1x1_new.tif")
# load europe shapefiles
europe_shape <- read_sf("datasets/ne_50m_admin_0_countries/ne_50m_admin_0_countries.shp")
europe_shape <- europe_shape[europe_shape$CONTINENT == "Europe",]
# cities above populaiton of 1 million
cities <- world.cities[world.cities$pop >= 1000000, ]
cities <- cities %>% st_as_sf(coords = c("long", "lat"), crs = 4326) %>%
  st_cast("POINT")
cities <- st_intersection(cities, st_union(europe_shape))
denver_grouped_state <- as.data.frame(read_csv("datasets/denver.csv"))
roads_hamburg <- read_sf("datasets/hamburg.shp")
bakeries <- read_sf("datasets/bakeries.kml")
```

# Andere R Pakete
**tmap** ist natürlich nicht das einzige Paket mit dem Karten erstellt werden können. Es gibt eine Vielzahl an Paketen die verwendet werden können um geographische Daten zu visualisieren. Einige von diesen werden in diesem Kapitel vorgestellt.

## ggplot2 und ggspatial
**ggplot2** ist eins der am häufigsten benutzten Pakete zur Datenvisualisierung in R. Es wird hauptsächlich in Verbindung mit normalen Daten verwendet, kann aber auch zur Darstellung von geographischen Daten verwendet werden. Um die Funktionalität zu erweitern, kann zusätzlich das Paket **ggspatial** verwendet werden. Dieses wurde entwickelt um  geographische Objekte in **ggplot2** Ebene zu verwandeln. Dies beinhaltet Vektor-, Rasterdaten und Hintergrundkarten. Um Geodaten in **ggplot2** hinzuzufügen können die Funktionen `geom_sf`, `geom_sf_label` und `geom_sf_text` verwendet werden.
```{r, fig.align="center", fig.cap="Karte mit ggplot2"}
ggplot(data = honey2008) +
  geom_sf(aes(fill = Price_per_lb))
```
Mit `ggspatial` kann vorallem das Drumherum der Karte verändert werden. Es kann, wie auch in **tmap**, eine Maßstabsleiste, ein Kompass und eine Hintergrundkarte hinzugefügt werden:
```{r, message=FALSE, warning=FALSE, fig.align="center", fig.cap="Verwendung von ggplot2 und ggspatial"}
ggplot(data = honey2008) +
  annotation_map_tile(type = "stamenwatercolor") +
  geom_sf_label(aes(label = Price_per_lb)) +
  geom_sf(data = honey2008_multi) +
  annotation_scale(location = "tl") +
  annotation_north_arrow(location = "br", which_north = "true") 
```

Timo Grossenbacher zeigt in seinem Blog wie man mit **gplot2** leicht zu interpretierende Karten gestalten kann:

```{r, echo=FALSE,warning=FALSE,message=FALSE,fig.align="center",fig.cap="Karte der Schweiz in ggplot2"}
theme_map <- function(...) {
  theme_minimal() +
  theme(
    text = element_text(family = "Ubuntu Regular", color = "#22211d"),
    axis.line = element_blank(),
    axis.text.x = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    # panel.grid.minor = element_line(color = "#ebebe5", size = 0.2),
    panel.grid.major = element_line(color = "#ebebe5", size = 0.2),
    panel.grid.minor = element_blank(),
    plot.background = element_rect(fill = "#f5f5f2", color = NA), 
    panel.background = element_rect(fill = "#f5f5f2", color = NA), 
    legend.background = element_rect(fill = "#f5f5f2", color = NA),
    panel.border = element_blank(),
    ...
  )
}
data <- read.csv("switzerland/input/avg_age_15.csv", stringsAsFactors = FALSE)
gde_15 <- readOGR("switzerland/input/geodata/gde-1-1-15.shp", layer = "gde-1-1-15")
# set crs to ch1903/lv03, just to make sure  (EPSG:21781)
crs(gde_15) <- "+proj=somerc +lat_0=46.95240555555556 
+lon_0=7.439583333333333 +k_0=1 +x_0=600000 +y_0=200000 
+ellps=bessel +towgs84=674.374,15.056,405.346,0,0,0,0 +units=m +no_defs"
# fortify, i.e., make ggplot2-compatible
map_data_fortified <- fortify(gde_15, region = "BFS_ID") %>% 
  mutate(id = as.numeric(id))
# now we join the thematic data
map_data <- map_data_fortified %>% left_join(data, by = c("id" = "bfs_id"))

# whole municipalities
gde_15_political <- readOGR("switzerland/input/geodata/g1g15.shp", layer = "g1g15")
crs(gde_15_political) <- "+proj=somerc +lat_0=46.95240555555556 
+lon_0=7.439583333333333 +k_0=1 +x_0=600000 +y_0=200000 
+ellps=bessel +towgs84=674.374,15.056,405.346,0,0,0,0 +units=m +no_defs"
map_data_political_fortified <- fortify(gde_15_political, region = "GMDNR") %>% 
  mutate(id = as.numeric(id))
map_data_political <- map_data_political_fortified %>% left_join(data, by = c("id" = "bfs_id"))
map_data_political <- map_data_political[complete.cases(map_data_political),]
# read in background relief
relief <- raster("switzerland/input/geodata/02-relief-georef-clipped-resampled.tif")
relief_spdf <- as(relief, "SpatialPixelsDataFrame")
# relief is converted to a very simple data frame, 
# just as the fortified municipalities.
# for that we need to convert it to a 
# SpatialPixelsDataFrame first, and then extract its contents 
# using as.data.frame
relief <- as.data.frame(relief_spdf) %>% 
  rename(value = `X02.relief.georef.clipped.resampled`)
# remove unnecessary variables
rm(relief_spdf)
rm(gde_15)
rm(map_data_fortified)
rm(map_data_political_fortified)
pretty_breaks <- c(40,42,44,46,48)
# find the extremes
minVal <- min(map_data$avg_age_15, na.rm = T)
maxVal <- max(map_data$avg_age_15, na.rm = T)
# compute labels
labels <- c()
brks <- c(minVal, pretty_breaks, maxVal)
# round the labels (actually, only the extremes)
for(idx in 1:length(brks)){
  labels <- c(labels,round(brks[idx + 1], 2))
}

labels <- labels[1:length(labels)-1]
# define a new variable on the data set just as above
map_data$brks <- cut(map_data$avg_age_15, 
                     breaks = brks, 
                     include.lowest = TRUE, 
                     labels = labels)

brks_scale <- levels(map_data$brks)
labels_scale <- rev(brks_scale)
ggplot() +
    # raster comes as the first layer, municipalities on top
    geom_raster(data = relief, aes(x = x, 
                                  y = y, 
                                  alpha = value)) +
    # use the "alpha hack"
    scale_alpha(name = "", range = c(0.6, 0), guide = F)  + 
    # municipality polygons
    geom_polygon(data = map_data, aes(fill = brks, 
                                      x = long, 
                                      y = lat, 
                                      group = group)) +
    # municipality outline
    geom_path(data = map_data, aes(x = long, 
                                   y = lat, 
                                   group = group), 
              color = "white", size = 0.1) +
    # apart from that, nothing changes
    coord_equal() +
    theme_map() +
    theme(legend.position = "bottom", plot.title = element_text(hjust = 0.5),
          plot.subtitle = element_text(hjust = 0.5)) +
    labs(x = NULL, 
         y = NULL, 
         title = "Switzerland's regional demographics", 
         subtitle = "Average age in Swiss municipalities, 2015", 
         caption = "Geometries: ThemaKart, BFS; Data: BFS, 2016; Relief: swisstopo, 2016") + 
    scale_fill_manual(
      values = rev(scico(8, palette = "davos")[2:7]),
      breaks = rev(brks_scale),
      name = "Average age",
      drop = FALSE,
      labels = labels_scale,
      guide = guide_legend(
        direction = "horizontal",
        keyheight = unit(2, units = "mm"), 
        keywidth = unit(70/length(labels), units = "mm"),
        title.position = 'top',
        title.hjust = 0.5,
        label.hjust = 1,
        nrow = 1,
        byrow = T,
        reverse = T,
        label.position = "bottom"
      )
    )
```

[@ggswitz]

## mapview
Das **mapview** Paket wurde mit dem Ziel erstellt schnell interaktive Karten zu erstellen. Die wichtigste Funktion stellt dabei `mapview()` dar, mit der die Karten erstellt werden. Mit dem Argument `zcol` kann bestimmt werden, nach welcher Variable die Elemente eingefärbt werden sollen. Basierend auf den Farben der einzelnen Elemente der Karte wird automatisch eine Hintergrundkarte ausgewählt.
```{r, fig.align="center", fig.cap="Arbeitslosenquote in Bayern, 2015"}
mapview(bavaria, zcol = "Arbeitslosenquote")
```

Mit dem Argument `at` könnten noch eigene Intervallgrenzen definiert werden, basierend auf denen eingefärbt werden soll.
Um mehrere Karten gleichzeitig zu visualisieren, können mehrere `mapview()` Funktionen mit `+` verbunden werden. So kann die europäische Höhenrasterkarte aus Kapitel 2 reproduziert werden:
```{r, fig.align="center", fig.cap="Mehrere Ebenen übereinander"}
mapview(europe_raster, legend = FALSE) +
  mapview(europe_shape, legend = FALSE, alpha.regions = 0) +
  mapview(cities, legend = FALSE, cex = "pop")
```

Bei dieser Karte fallen direkt mehrere Sachen auf. Es wird das komplette Shapefile dargestellt, nicht nur die Gebiete innerhalb des Rasters. So werden unteranderem Spitzbergen und die französischen Überseegebiete dargestellt. Mit `cex` wurde festgelegt, dass die Größe der Punkte auf der Population der jeweiligen Städte basiert und mit `alpha.regions` wurde die Transparenz der Polygone reduziert. Rechts unten kann auf *cities*, *europe_shape* oder *europe_raster* geklickt werden, um einen dieser Bereich zu fokusieren. Mit einem Klick auf eine der Städte oder eines der Länder öffnet sich ein Popup in dem weitere Infos zu der Stadt beziehungsweise dem Land stehen. 
Wird zusätzlich zu `zcol` das Argument `burst = TRUE` verwendet, wird für jeden einzigartigen Wert der gewählten Variable eine einzelne Ebene erstellt, die fokusiert oder ausgeblendet werden kann. Mit `col.regions` kann eine Palette ausgewählt werden.
```{r, fig.align="center", fig.cap="Flughäfen und Autobahnen in Bayern"}
mapview(autobahn, color = "red", lwd = 3,
                 layer.name = "Autobahn", legend = FALSE) +
  mapview(bavaria, zcol = "Name", burst = TRUE, col.regions = brewer.pal(7, "Dark2")) +
  mapview(airports, legend = FALSE, col.regions = "black")
```

Mit den Funktionen `popupTable()` und `popupGraph()` aus dem **leafpop** Paket kann bestimmt werden welche Variablen in dem Popup erscheinen sollen oder einen Graph anzeigen.
```{r, fig.align="center", fig.cap="Benutzerdefinierte Popups"}
mapview(bavaria, zcol = "Name", col.regions = brewer.pal(7, "Dark2"),
        popup = popupTable(bavaria, zcol = c("Arbeitslosenquote", "Beschaeftigtenquote", "Haushaltseinkommen")))
```

```{r, fig.align="center", fig.cap="Grafiken als Popups"}
p <- xyplot(Bevoelkerungsentwicklung ~ Durchschnittsalter , data = bavaria, col = "grey", pch = 20, cex = 2, alpha = 0.7)
p <- mget(rep("p", nrow(bavaria)))
clr <- rep("grey", nrow(bavaria))
p <- lapply(1:length(p), function(i) {
  clr[i] <- "red"
  update(p[[i]], col = clr)
})

mapview(bavaria, zcol = "Name", col.regions = brewer.pal(7, "Dark2"),
        popup = popupGraph(p))
```

Da bei den Scatterplots manche x-y Kombinationen mehrmals vorkommen, wird nicht jedes mal ein roter Punkt angezeigt. Mit den Funktionen `leafpop::popupImage()` oder `leafpop:::popupIframe()` können sogar Bilder, Hyperlinks und Youtube-Videos eingebunden werden.

## mapdeck
**mapdeck** ist ein R-Paket mit dem interaktive Karten unter Verwendung von *mapbox GL* und *Deck.gl* erstellt werden können. Mapbox ist eine Standortdaten Plattform mit der verschiedene Applikationen erstellt werden können. Deck.gl ist ein Framework zur Visualierung großer Datensätze. Für die Verwendung des Pakets wird allerdings ein Mapbox-Token benötigt, der mit `set_token("token")` gesetzt wird. Um einen solchen Token zu erhalten, muss ein Konto auf https://www.mapbox.com/ eingerichtet werden.
Die Syntax von **mapdeck** ähnelt der von **ggplot2** im Sinne davon, dass zu Beginn die Funktion `mapdeck()` aufgerufen wird, gefolgt von verschiedenen Ebene mittels `add_*()`. Anstelle des `+` Operators wird allerdings der Pipe Operator `%>%` verwendet. Mit der Funktion `mapdeck_style()` kann eine von sechs verschiedenen Hintergrundkarten ausgewählt werden. `add_arc()` fügt Bögen hinzu, die von einem Punkt zu einem anderen gehen. Die Punkte können dabei entweder `sfc` Objekte oder numerische Werte sein. Mit `stroke_from` und `stroke_to` kann jeweils eine Variable ausgewählt werden nach der eine Hälfte des Bogens eingefärbt werden soll.
```{r, fig.align="center", fig.cap="Flüge von Denver aus in die einzelnen Bundestaaten, 1987-2008"}
ms <- mapdeck_style("dark")
mapdeck(style = ms, pitch = 45, zoom = 1) %>%
  add_arc(data = denver_grouped_state,
          origin = c("long_denver", "lat_denver"),
          destination = c("long", "lat"),
          stroke_from = "no_of_flights",
          stroke_to = "no_of_flights",
          stroke_width = 2,
          legend = TRUE)
```

```{r, include=FALSE}
roads_hamburg_grouped <- roads_hamburg
roads_hamburg_grouped[roads_hamburg_grouped$type %in% c("motorway", "motorway_link",
                                                        "primary", "primary_link",
                                                        "trunk", "trunk_link"), ]$type = "Main roads"
roads_hamburg_grouped[roads_hamburg_grouped$type %in% c("secondary", "secondary_link",
                                                        "tertiary", "tertiary_link",
                                                        "unclassified"), ]$type = "Secondary roads"
roads_hamburg_grouped[roads_hamburg_grouped$type %in% c("living_street", "pedestrian", "residential"), ]$type = "Residential roads"
```

Mit `add_path` können `LINESTRING` und `MULTILINESTRING` Elemente zu einer Karte hinzugefügt werden.

```{r, fig.align="center", fig.cap="Straßennetz in Hamburg"}
mapdeck(style = mapdeck_style("light")) %>%
  add_path(data = roads_hamburg_grouped,
           stroke_colour = "#E2E2E2")
```

Mit `stroke_colour` kann wieder eine Farbe für die Einfärbung der Elemente ausgewählt werden. Mit `palette` kann entweder eine der Paletten aus dem `colourvalues` Paket ausgewählt werden. Die verfügbaren können entweder mit `colourvalues::colour_palettes()` oder `colourvalues::show_colours()` angezeigt werden. Alternativ kann auch eine eigene Farbmatrix übergeben werden, wie in dem folgenden Beispiel.

```{r, fig.align="center", fig.cap="Straßennetz in Hamburg mit eigener Farbmatrix"}
mapdeck(style = ms) %>%
  add_path(data = roads_hamburg_grouped,
           stroke_colour = "type",
           legend = TRUE,
           palette = colorRamp(c("#FF8300", "#F890E7", "#0BD3D3"))( (1:256)/256 ))
```

Mit `add_grid` kann eine gridbasierte Heatmap erstellt werden. Basierend auf der Anzahl der Elemente innerhalb einzelner Zellen werden verschiedene hohe Balken dargestellt. Die Zellgröße in Metern kann mit `cell_size` festgelegt werden und der Höhenmultiplikator mit `elevation_scale`.

```{r, fig.align="center", fig.cap="Anzahl Bäckereien in Europa"}
mapdeck(style = ms, pitch = 45) %>%
  add_grid(data = bakeries, cell_size = 1000,
           elevation_scale = 75,
           colour_range = brewer.pal(6, "YlOrRd"))
```

## leaflet
**leaflet** ist eine open-source JavaScript-Bibliothek mit der dynamische Onlinekarten erstellt werden. Das gleichnamige R Paket ermöglicht es diese Art von Karten auch in R zu erstellen. Die Syntax ist identisch zur **mapdeck** Syntax. Zuerst wird die Funktion `leaflet()` aufgerufen, gefolgt von verschiedenen Ebenen mit `add*()`. Auch hier wird der Pipe Operator `%>%` verwendet, um die einzelnen Funktionen miteinander zu verknüpfen.
Um Punktdaten darzustellen können die Funktionen `addMarkers()`, `addCircleMarkers()` und `addAwesomeMarkers()` verwendet werden, für Polygondaten `addPolygons()`, für `LINESTRING` Geometrien `addPolylines()` und für Rasterdaten `addRasterImage()`. Das `label` Argument kann bei diesen verwendet werden, um eine Box über dem Marker anzuzeigen, wenn der Benutzer seinen Mauszeiger darüber bewegt. Mit `addTiles()` und `addProvidersTiles()` können Hintergrundkarten hinzugefügt werden, mit `addLegend()` eine Legende. **leaflet** bietet die Möglichkeit, mehrere Hintergrundkarten zu definieren und eine Auswahlfläche hinzuzufügen, um zwischen diesen zu entscheiden. Dafür müssen mehrere `addProvidersTiles()` Funktionen miteinander verknüpft werden und eine Kontrollbox mit `addLayersControl()` hinzugefügt werden.
```{r, include = FALSE}
coords <- read_csv("leaflet_data/coords_1.csv")
isochrone <- read_sf("leaflet_data/isochrone_1.shp")
poly_data <- read_sf("leaflet_data/poly_data_1.shp")
points <- read_sf("leaflet_data/points_1.shp")
icon.fa <- makeAwesomeIcon(
  icon = "flag", markerColor = "red",
  library = "fa",
  iconColor = "black"
)
```

```{r, fig.align="center", fig.cap="Apotheken innerhalb eines 20-Minuten Fensters"}
leaflet() %>%
  # all Karten hinzufügen
  addTiles(
    group = "OpenStreetMap",
    options = providerTileOptions(noWrap = TRUE)
  ) %>%
  addProviderTiles("Stamen.Toner",
                   group = "Stamen.Toner"
  ) %>%
  addProviderTiles("Stamen.Terrain",
                   group = "Stamen.Terrain"
  ) %>%
  addProviderTiles("Esri.WorldStreetMap",
                   group = "Esri.WorldStreetMap"
  ) %>%
  addProviderTiles("Wikimedia",
                   group = "Wikimedia"
  ) %>%
  addProviderTiles("CartoDB.Positron",
                   group = "CartoDB.Positron"
  ) %>%
  addProviderTiles("Hydda",
                   group = "Hydda"
  ) %>%
  # Kontrollbox hinzufügen
  addLayersControl(
    baseGroups = c(
      "OpenStreetMap", "Stamen.Toner",
      "Stamen.Terrain", "Esri.WorldStreetMap",
      "Wikimedia", "CartoDB.Positron", "Hydda"
    ),
    position = "topleft"
  ) %>%
  # Polygon hinzufügen
  addPolygons(
    data = poly_data,
    color = "#E84A5F"
  ) %>%
  # Startpunkt hinzufügen
  addAwesomeMarkers(
    lat = as.numeric(coords[, 2]), lng = as.numeric(coords[, 1]),
    label = "Starting point", icon = icon.fa
  ) %>%
  # Punkte hinzufügen
  addMarkers(
    data = points,
    label = paste(
      "Name: ", points$name, "<br>",
      "Distance from location. ",
      round(points$dstnc, 1), " meters", "<br>",
      "Street: ", points$addr_st
    ) %>%
      lapply(htmltools::HTML)
  ) %>%
  # Legende hinzufügen
  addLegend(
    data = isochrone,
    colors = "#E84A5F",
    labels = unique(poly_data$labs),
    title = "Drivetime",
    opacity = 1, 
    position = "bottomleft"
  )
```

Um eine bestimmte Farbpalette für die Visualisierung einzelner Elemente zu verwenden, können die Helferfunktionen `colorNumeric()`, `colorBin()`, `colorQuantile()` und `colorFactor()` übergeben werden. Diese benötigen die Farbcodes der Palette (`palette`) und alle möglichen Werte die dargestellt werden können (`domain`).
Mit `addMiniMap()` kann eine kleine Karte zu der großen hinzugefügt werden.

```{r, include = FALSE}
intersect <- read_sf("leaflet_data/intersect_2.shp")
points_df <- read_csv("leaflet_data/points_df_2.csv")
polygons <- read_sf("leaflet_data/polygons_2.shp")
```
```{r, fig.align="center", fig.cap="Clustering der Apotheken in München mit DBSCAN Algorithmus"}
# Farbfunktionen definieren
pal <- colorNumeric(c("#E1F5C4", "#EDE574", "#F9D423", "#FC913A", "#FF4E50"), domain = points_df$count)
pal2 <- colorNumeric(
  brewer.pal(9, "Greens")[3:9],
  intersect$einwohner
)
leaflet() %>%
  # Hintergrundkarte
  addProviderTiles("CartoDB.DarkMatter") %>%
  # PLZ-Daten hinzufügen
  addPolygons(
    data = intersect, color = ~ pal2(einwohner),
    fillColor = ~ pal2(einwohner),
    # Label hinzufügen
    label = paste(
      "ZIP code:", intersect$plz,
      "<br>", "Residents:",
      intersect$einwohner
    ) %>%
      lapply(htmltools::HTML)
  ) %>%
  # Cluster Polygone hinzufügen
  addPolygons(
    data = polygons, color = "#E2E2E2",
    opacity = 0.1
  ) %>%
  # Punkte hinzufügen
  addCircleMarkers(
    data = points_df, lat = ~latitude,
    lng = ~longitude,
    label = paste(
      "Name:",
      points_df$name, "<br>",
      "Cluster:",
      points_df$cluster, "<br>",
      "Cluster size:",
      points_df$count, "<br>",
      "Street: ",
      points_df$addr.street
    ) %>%
      # Label hinzufügen
      lapply(htmltools::HTML),
    color = ~ pal(count),
    opacity = 0.65, radius = 5
  ) %>%
  # Legende für PLZ hinzufügen
  addLegend(
    data = intersect, pal = pal2,
    values = ~einwohner,
    title = "Number of residents:",
    opacity = 1,
    position = "bottomleft"
  ) %>%
  # Legende für Punkte hinzufügen
  addLegend(
    data = points_df, pal = pal, values = ~count,
    position = "bottomleft", title = "Cluster size:",
    opacity = 0.9
  ) %>%
  # Mini Map hinzufügen
  addMiniMap(tiles = "CartoDB.DarkMatter")
```

Anstelle von `sf` Objekten können auch `sp` Objekte übergeben werden. So kann beispielsweise eine 2D-Heatmap mit Hilfe des **KernSmooth** Pakets berechnet werden und wie folgt dargestellt werden. Mit `addMeasure()` wird hier noch ein Maßband hinzugefügt, mit dem Distanz zwischen zwei Punkten oder die Fläche zwischen mehreren Punkten berechnet werden kann.
```{r, include = FALSE}
points_df <- read_csv("leaflet_data/points_df_3.csv")
streets_c <- read_sf("leaflet_data/streets_c_3.shp")
points_df <- as.data.frame(points_df)
```
```{r, fig.align="center", fig.cap="Heatmap der Apotheken in München mit Straßennetz"}
# Dichte berechnen
kde <- bkde2D(
  points_df[, c("longitude", "latitude")],
  bandwidth = c(.0045, .0045), gridsize = c(1500, 1500)
)
# Kontourlinien
CL <- contourLines(kde$x1, kde$x2, kde$fhat)
LEVS <- as.factor(sapply(CL, `[[`, "level"))
NLEV <- length(levels(LEVS))
## Linien zu Polygons
pgons <- lapply(1:length(CL), function(i)
  Polygons(list(Polygon(cbind(CL[[i]]$x, CL[[i]]$y))), ID = i))
spgons <- SpatialPolygons(pgons)
leaflet() %>%
  addProviderTiles("CartoDB.DarkMatter", group = "CartoDB") %>%
  addProviderTiles("Thunderforest.TransportDark", group = "Thunderforest") %>%
  addLayersControl(
    baseGroups = c(
      "CartoDB", "Thunderforest"
    ),
    position = "topleft"
  ) %>%
  addPolygons(
    data = spgons,
    color = heat.colors(NLEV, NULL)[LEVS],
    opacity = 0.4
    ) %>%
  addPolylines(
    data = streets_c, opacity = 1, weight = 1,
    color = "white"
    ) %>%
  addMeasure(
    position = "bottomleft",
    primaryLengthUnit = "meters",
    primaryAreaUnit = "sqmeters",
    activeColor = "#0bd3d3",
    completedColor = "#f890e7"
    ) %>%
  addMiniMap()
```

Da es sich bei **leaflet** um eine JavaScript Bibliothek handelt, kann auch JavaScript Code eingebunden werden. Werden beispielsweise mehrere Hintergrundkarten und eine MiniMap hinzugefügt, wird standardmäßig nur die erste Karte als MiniMap angezeigt, auch wenn eine andere Hintergrundkarte ausgewählt wird. Um dieses Verhalten zu ändern, kann über die Funktion `htmltools::onRender()` JavaScript eingebunden werden.
```{r, fig.align="center", fig.cap="Minimap wechselt mit Hintergrundkarte"}
leaflet() %>%
  clearShapes() %>%
  clearMarkers() %>%
  clearControls() %>%
  addTiles(
    group = "OpenStreetMap",
    options = providerTileOptions(noWrap = TRUE)
  ) %>%
  addProviderTiles("Stamen.Toner",
                   group = "Stamen.Toner"
  ) %>%
  addProviderTiles("Stamen.Terrain",
                   group = "Stamen.Terrain"
  ) %>%
  addProviderTiles("Esri.WorldStreetMap",
                   group = "Esri.WorldStreetMap"
  ) %>%
  addProviderTiles("Wikimedia",
                   group = "Wikimedia"
  ) %>%
  addProviderTiles("CartoDB.Positron",
                   group = "CartoDB.Positron"
  ) %>%
  addProviderTiles("Hydda",
                   group = "Hydda"
  ) %>%
  addMiniMap(tiles = c("OpenStreetMap", "Stamen.Toner", "Stamen.Terrain",
                       "Esri.WorldStreetMap", "Wikimedia", "CartoDB.Positron",
                       "Hydda")[1], toggleDisplay = TRUE) %>%
  htmlwidgets::onRender("
    function(el, x) {
      var myMap = this;
      myMap.on('baselayerchange',
        function (e) {
          myMap.minimap.changeLayer(L.tileLayer.provider(e.name));
        })
    }") %>%
  addLayersControl(
    baseGroups = c(
      "OpenStreetMap", "Stamen.Toner",
      "Stamen.Terrain", "Esri.WorldStreetMap",
      "Wikimedia", "CartoDB.Positron", "Hydda"
    ),
    
    position = "topleft"
  ) %>%
  addPolygons(
    data = poly_data,
    color = "#E84A5F"
  ) %>%
  addLegend(
    data = isochrone,
    colors = "#E84A5F",
    labels = unique(poly_data$labs),
    title = "Drivetime",
    opacity = 1, 
    position = "bottomleft"
  ) %>%
  addAwesomeMarkers(
    lat = as.numeric(coords[, 2]), lng = as.numeric(coords[, 1]),
    label = "Starting point", icon = icon.fa
  ) %>%
  addMarkers(
    data = points,
    label = paste(
      "Name: ", points$name, "<br>",
      "Distance from location. ",
      round(points$dstnc, 1), " meters", "<br>",
      "Street: ", points$addr_st
    ) %>%
      lapply(htmltools::HTML)
  )
```

JavaScript kann auch verwendet werden um Punktdaten zu Clustern zusammenzufassen, die bei einem Klick auf das jeweilige Cluster expandieren:
```{r}
leaflet() %>% addTiles() %>%
  addMarkers(data=points_df,
             clusterOptions = markerClusterOptions(),
             clusterId = "pointsCluster") %>%
  addEasyButton(easyButton(
    states = list(
      easyButtonState(
        stateName="unfrozen-markers",
        icon="ion-toggle",
        title="Freeze Clusters",
        onClick = JS("
          function(btn, map) {
            var clusterManager =
              map.layerManager.getLayer('cluster', 'pointsCluster');
            clusterManager.freezeAtZoom();
            btn.state('frozen-markers');
          }")
      ),
      easyButtonState(
        stateName="frozen-markers",
        icon="ion-toggle-filled",
        title="UnFreeze Clusters",
        onClick = JS("
          function(btn, map) {
            var clusterManager =
              map.layerManager.getLayer('cluster', 'pointsCluster');
            clusterManager.unfreeze();
            btn.state('unfrozen-markers');
          }")
      )
    )
  ))
```

