---
title: "5-other_packages"
author: "Nico Hahn"
date: "21 August 2019"
output: html_document
---

```{r, include=FALSE}
library(sf)
library(ggplot2)
library(ggspatial)
library(mapdeck)
library(mapview)
library(leaflet)
library(plotly)
library(rgeos)
library(rgdal)
library(raster)
library(dplyr)
library(gtable)
library(grid)
library(readxl)
honey <- read_sf("honey.shp")
colnames(honey)[3:8] <- c("Number_of_colonies", "Yield_per_colony",
                          "Total_production", "Stocks","Price_per_lb",
                          "Value_of_production"
                          )
honey2008 <- honey[honey$year == 2008, ]
honey2008_multi <- st_cast(honey2008, "MULTILINESTRING")
```

# Andere R Pakete
**tmap** ist natürlich nicht das einzige Paket mit dem Karten erstellt werden können. Es gibt eine Vielzahl an Paketen die verwendet werden können um geographische Daten zu visualisieren. Einige von diesen werden in diesem Kapitel vorgestellt.

## ggplot2 und ggspatial
**ggplot2** ist eins der am häufigsten benutzten Pakete zur Datenvisualisierung in R. Es wird hauptsächlich in Verbindung mit normalen Daten verwendet, kann aber auch zur Darstellung von geographischen Daten verwendet werden. Um die Funktionalität zu erweitern, kann zusätzlich das Paket **ggspatial** verwendet werden. Dieses wurde entwickelt um  geographische Objekte in **ggplot2** Ebene zu verwandeln. Dies beinhaltet Vektor-, Rasterdaten und Hintergrundkarten. Um Geodaten in **ggplot2** hinzuzufügen können die Funktionen `geom_sf`, `geom_sf_label` und `geom_sf_text` verwendet werden.
```{r, fig.align="center", fig.cap="Karte mit ggplot2"}
ggplot(data = honey2008) +
  geom_sf(aes(fill = Price_per_lb))
```
Mit `ggspatial` kann vorallem das Drumherum der Karte verändert werden. Es kann, wie auch in **tmap**, eine Maßstabsleiste, ein Kompass und eine Hintergrundkarte hinzugefügt werden:
```{r, message=FALSE, warning=FALSE, fig.align="center", fig.cap="Verwendung von ggplot2 und ggspatial"}
ggplot(data = honey2008) +
  annotation_map_tile(type = "stamenwatercolor") +
  geom_sf_label(aes(label = Price_per_lb)) +
  geom_sf(data = honey2008_multi) +
  annotation_scale(location = "tl") +
  annotation_north_arrow(location = "br", which_north = "true") 
```

Timo Grossenbacher zeigt in seinem Blog wie man mit **gplot2** leicht zu interpretierende Karten gestalten kann:
HIER ZITAT EINFÜGEN

```{r, echo=FALSE,warning=FALSE,message=FALSE,fig.align="center",fig.cap=""}
theme_map <- function(...) {
  theme_minimal() +
  theme(
    text = element_text(family = "Ubuntu Regular", color = "#22211d"),
    axis.line = element_blank(),
    axis.text.x = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    # panel.grid.minor = element_line(color = "#ebebe5", size = 0.2),
    panel.grid.major = element_line(color = "#ebebe5", size = 0.2),
    panel.grid.minor = element_blank(),
    plot.background = element_rect(fill = "#f5f5f2", color = NA), 
    panel.background = element_rect(fill = "#f5f5f2", color = NA), 
    legend.background = element_rect(fill = "#f5f5f2", color = NA),
    panel.border = element_blank(),
    ...
  )
}
data <- read.csv("stolen_code/input/avg_age_15.csv", stringsAsFactors = FALSE)
gde_15 <- readOGR("stolen_code/input/geodata/gde-1-1-15.shp", layer = "gde-1-1-15")
# set crs to ch1903/lv03, just to make sure  (EPSG:21781)
crs(gde_15) <- "+proj=somerc +lat_0=46.95240555555556 
+lon_0=7.439583333333333 +k_0=1 +x_0=600000 +y_0=200000 
+ellps=bessel +towgs84=674.374,15.056,405.346,0,0,0,0 +units=m +no_defs"
# fortify, i.e., make ggplot2-compatible
map_data_fortified <- fortify(gde_15, region = "BFS_ID") %>% 
  mutate(id = as.numeric(id))
# now we join the thematic data
map_data <- map_data_fortified %>% left_join(data, by = c("id" = "bfs_id"))

# whole municipalities
gde_15_political <- readOGR("stolen_code/input/geodata/g1g15.shp", layer = "g1g15")
crs(gde_15_political) <- "+proj=somerc +lat_0=46.95240555555556 
+lon_0=7.439583333333333 +k_0=1 +x_0=600000 +y_0=200000 
+ellps=bessel +towgs84=674.374,15.056,405.346,0,0,0,0 +units=m +no_defs"
map_data_political_fortified <- fortify(gde_15_political, region = "GMDNR") %>% 
  mutate(id = as.numeric(id))
map_data_political <- map_data_political_fortified %>% left_join(data, by = c("id" = "bfs_id"))
map_data_political <- map_data_political[complete.cases(map_data_political),]
# read in background relief
relief <- raster("stolen_code/input/geodata/02-relief-georef-clipped-resampled.tif")
relief_spdf <- as(relief, "SpatialPixelsDataFrame")
# relief is converted to a very simple data frame, 
# just as the fortified municipalities.
# for that we need to convert it to a 
# SpatialPixelsDataFrame first, and then extract its contents 
# using as.data.frame
relief <- as.data.frame(relief_spdf) %>% 
  rename(value = `X02.relief.georef.clipped.resampled`)
# remove unnecessary variables
rm(relief_spdf)
rm(gde_15)
rm(map_data_fortified)
rm(map_data_political_fortified)
pretty_breaks <- c(40,42,44,46,48)
# find the extremes
minVal <- min(map_data$avg_age_15, na.rm = T)
maxVal <- max(map_data$avg_age_15, na.rm = T)
# compute labels
labels <- c()
brks <- c(minVal, pretty_breaks, maxVal)
# round the labels (actually, only the extremes)
for(idx in 1:length(brks)){
  labels <- c(labels,round(brks[idx + 1], 2))
}

labels <- labels[1:length(labels)-1]
# define a new variable on the data set just as above
map_data$brks <- cut(map_data$avg_age_15, 
                     breaks = brks, 
                     include.lowest = TRUE, 
                     labels = labels)

brks_scale <- levels(map_data$brks)
labels_scale <- rev(brks_scale)
ggplot() +
    # raster comes as the first layer, municipalities on top
    geom_raster(data = relief, aes(x = x, 
                                  y = y, 
                                  alpha = value)) +
    # use the "alpha hack"
    scale_alpha(name = "", range = c(0.6, 0), guide = F)  + 
    # municipality polygons
    geom_polygon(data = map_data, aes(fill = brks, 
                                      x = long, 
                                      y = lat, 
                                      group = group)) +
    # municipality outline
    geom_path(data = map_data, aes(x = long, 
                                   y = lat, 
                                   group = group), 
              color = "white", size = 0.1) +
    # apart from that, nothing changes
    coord_equal() +
    theme_map() +
    theme(legend.position = "bottom", plot.title = element_text(hjust = 0.5),
          plot.subtitle = element_text(hjust = 0.5)) +
    labs(x = NULL, 
         y = NULL, 
         title = "Switzerland's regional demographics", 
         subtitle = "Average age in Swiss municipalities, 2015", 
         caption = "Geometries: ThemaKart, BFS; Data: BFS, 2016; Relief: swisstopo, 2016") + 
    scale_fill_manual(
      values = rev(scico::scico(8, palette = "davos")[2:7]),
      breaks = rev(brks_scale),
      name = "Average age",
      drop = FALSE,
      labels = labels_scale,
      guide = guide_legend(
        direction = "horizontal",
        keyheight = unit(2, units = "mm"), 
        keywidth = unit(70/length(labels), units = "mm"),
        title.position = 'top',
        title.hjust = 0.5,
        label.hjust = 1,
        nrow = 1,
        byrow = T,
        reverse = T,
        label.position = "bottom"
      )
    )
```

## plotly
**plotly** ist eine JavaScript library mit deren Hilfe interaktive webbasierte Grafiken erstellt werden können. In R kann mit dem gleichnamigen Paket auf diese zurückgegriffen werden. Wie auch in **gplot2** und **tmap** wird zuerst die Funktion `plot_ly()` aufgerufen um die inputs zu definieren, ehe mehrere Ebenenen hinzugefügt werden können. Allerdings wird anstelle von `+` der Pipe Operator `%>%` verwendet um die Funktionen miteinander zu verknüpfen. Um Geodaten darzustellen kann alternativ auch `plot_geo()` oder `plot_mapbox()` aufgerufen, anstelle von `plot_ly()`. Für Zweiteres wird allerdings ein Mapbox-Token benötigt, der mit `Sys.setenv('MAPBOX_TOKEN' = 'token')` gesetzt wird. Um einen solchen Token zu erhalten, muss man ein Konto auf https://www.mapbox.com/ einrichten. 

```{r, message=FALSE}
plot_ly(honey2008)
```

