---
title: "mapview"
author: "Nico Hahn"
date: "27 8 2019"
output: html_document
---

```{r, include=FALSE}
bavaria <- st_read("datasets/bavaria.shp")
# nicer colnames
colnames(bavaria) <- c(
  "Ort", "Art", "BIP je Einwohner", "Durchschnittsalter",
  "Siedlungsdichte", "Arbeitslosenquote",
  "Beschaeftigtenquote", "Haushaltseinkommen",
  "Studierende", "Bevoelkerungsentwicklung", "geometry"
)
# turn values into numeric
bavaria$`BIP je Einwohner` <- as.numeric(as.character(
  bavaria$`BIP je Einwohner`
))
bavaria$Durchschnittsalter <- as.numeric(as.character(
  bavaria$Durchschnittsalter
))
bavaria$Siedlungsdichte <- as.numeric(as.character(
  bavaria$Siedlungsdichte
))
bavaria$Arbeitslosenquote <- as.numeric(as.character(
  bavaria$Arbeitslosenquote
))
bavaria$Beschaeftigtenquote <- as.numeric(as.character(
  bavaria$Beschaeftigtenquote
))
bavaria$Haushaltseinkommen <- as.numeric(as.character(
  bavaria$Haushaltseinkommen
))
bavaria$Studierende <- as.numeric(as.character(
  bavaria$Studierende
))
bavaria$Bevoelkerungsentwicklung <- as.numeric(
  as.character(bavaria$Bevoelkerungsentwicklung)
)
bavaria$Ort <- as.character(bavaria$Ort)
reg <- st_read("datasets/regbez_ex.kml")
# intersections
bavaria <- st_intersection(bavaria, reg)
# more data
autobahn <- st_read("datasets/autobahn.kml")
airports <- st_read("datasets/airports.kml")
europe_raster <- raster("datasets/elevation1x1_new.tif")
# load europe shapefiles
europe_shape <- read_sf("datasets/ne_50m_admin_0_countries/ne_50m_admin_0_countries.shp")
europe_shape <- europe_shape[europe_shape$CONTINENT == "Europe",]
# cities above populaiton of 1 million
cities <- world.cities[world.cities$pop >= 1000000, ]
cities <- cities %>% st_as_sf(coords = c("long", "lat"), crs = 4326) %>%
  st_cast("POINT")
cities <- st_intersection(cities, st_union(europe_shape))
```

# Karten mit mapview
Das **mapview** Paket wurde mit dem Ziel erstellt schnell interaktive Karten zu erstellen. Die wichtigste Funktion stellt dabei `mapview()` dar, mit der die Karten erstellt werden. Mit dem Argument `zcol` kann bestimmt werden, nach welcher Variable die Elemente eingefärbt werden sollen. Basierend auf den Farben der einzelnen Elemente der Karte wird automatisch eine Hintergrundkarte ausgewählt.

```{r, fig.align="center", fig.cap="Arbeitslosenquote in Bayern, 2015", fig.height=9, eval=FALSE}
mapview(bavaria, zcol = "Arbeitslosenquote")
```
```{r, echo=FALSE}
htmltools::tags$iframe(src = "html_plots/mapview_1.html", width = "700px", height = "700px")
```

Mit dem Argument `at` könnten noch eigene Intervallgrenzen definiert werden, basierend auf denen eingefärbt werden soll.
Um mehrere Karten gleichzeitig zu visualisieren, können mehrere `mapview()` Funktionen mit `+` verbunden werden. So kann die europäische Höhenrasterkarte aus Kapitel 2 reproduziert werden:

```{r, fig.align="center", fig.cap="Mehrere Ebenen übereinander", warning=FALSE, message=FALSE, fig.height=9, eval=FALSE}
mapview(europe_raster, legend = FALSE) +
  mapview(europe_shape, legend = FALSE, alpha.regions = 0) +
  mapview(cities, legend = FALSE, cex = "pop")
```
```{r, echo=FALSE}
htmltools::tags$iframe(src = "html_plots/mapview_2.html", width = "700px", height = "700px")
```

Bei dieser Karte fallen direkt mehrere Sachen auf. Es wird das komplette Shapefile dargestellt, nicht nur die Gebiete innerhalb des Rasters. So werden unteranderem Spitzbergen und die französischen Überseegebiete dargestellt. Mit `cex` wurde festgelegt, dass die Größe der Punkte auf der Population der jeweiligen Städte basiert und mit `alpha.regions` wurde die Transparenz der Polygone reduziert. Rechts unten kann auf *cities*, *europe_shape* oder *europe_raster* geklickt werden, um einen dieser Bereich zu fokusieren. Mit einem Klick auf eine der Städte oder eines der Länder öffnet sich ein Popup in dem weitere Informationen zu der Stadt beziehungsweise dem Land stehen. 
Wird zusätzlich zu `zcol` das Argument `burst = TRUE` verwendet, wird für jeden einzigartigen Wert der gewählten Variable eine einzelne Ebene erstellt, die fokusiert oder ausgeblendet werden kann. Mit `col.regions` kann eine Palette ausgewählt werden.

```{r, fig.align="center", fig.cap="Flughäfen und Autobahnen in Bayern", fig.height=9, eval=FALSE}
mapview(autobahn, color = "red", lwd = 3,
                 layer.name = "Autobahn", legend = FALSE) +
  mapview(bavaria, zcol = "Name", burst = TRUE, col.regions = brewer.pal(7, "Dark2")) +
  mapview(airports, legend = FALSE, col.regions = "black")
```
```{r, echo=FALSE}
htmltools::tags$iframe(src = "html_plots/mapview_3.html", width = "700px", height = "700px")
```

Mit den Funktionen `popupTable()` und `popupGraph()` aus dem **leafpop** Paket kann bestimmt werden welche Variablen in dem Popup erscheinen sollen oder einen Graph anzeigen.

```{r, fig.align="center", fig.cap="Benutzerdefinierte Popups", fig.height=9, eval=FALSE}
mapview(bavaria, zcol = "Name", col.regions = brewer.pal(7, "Dark2"),
        popup = popupTable(bavaria, zcol = c("Arbeitslosenquote",
                                             "Beschaeftigtenquote",
                                             "Haushaltseinkommen")))
```
```{r, echo=FALSE}
htmltools::tags$iframe(src = "html_plots/mapview_4.html", width = "700px", height = "700px")
```

```{r, fig.align="center", fig.cap="Grafiken als Popups", fig.height=9, eval=FALSE}
p <- xyplot(Bevoelkerungsentwicklung ~ Durchschnittsalter , data = bavaria,
            col = "grey", pch = 20, cex = 2, alpha = 0.7)
p <- mget(rep("p", nrow(bavaria)))
clr <- rep("grey", nrow(bavaria))
p <- lapply(1:length(p), function(i) {
  clr[i] <- "red"
  update(p[[i]], col = clr)
})

mapview(bavaria, zcol = "Name", col.regions = brewer.pal(7, "Dark2"),
        popup = popupGraph(p))
```
```{r, echo=FALSE}
htmltools::tags$iframe(src = "html_plots/mapview_5.html", width = "700px", height = "700px")
```

Da bei den Scatterplots manche x-y Kombinationen mehrmals vorkommen, wird nicht jedes Mal ein roter Punkt angezeigt. Mit den Funktionen `leafpop::popupImage()` oder `leafpop:::popupIframe()` können sogar Bilder, Hyperlinks und Youtube-Videos eingebunden werden.
