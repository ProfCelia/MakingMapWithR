---
title: "Statische Karten"
author: "Nico Hahn"
date: "2 8 2019"
output: html_document
---
```{r, echo=FALSE, include=FALSE}
tmap_mode("plot")
# load shapefiles for bavaria
bavaria <- st_read("../datasets/bavaria.shp")
# nicer colnames
colnames(bavaria) <- c(
  "Ort", "Art", "BIP je Einwohner", "Durchschnittsalter",
  "Siedlungsdichte", "Arbeitslosenquote",
  "Beschaeftigtenquote", "Haushaltseinkommen",
  "Studierende", "Bevoelkerungsentwicklung", "geometry"
)
# turn values into numeric
bavaria$`BIP je Einwohner` <- as.numeric(as.character(
  bavaria$`BIP je Einwohner`
))
bavaria$Durchschnittsalter <- as.numeric(as.character(
  bavaria$Durchschnittsalter
))
bavaria$Siedlungsdichte <- as.numeric(as.character(
  bavaria$Siedlungsdichte
))
bavaria$Arbeitslosenquote <- as.numeric(as.character(
  bavaria$Arbeitslosenquote
))
bavaria$Beschaeftigtenquote <- as.numeric(as.character(
  bavaria$Beschaeftigtenquote
))
bavaria$Haushaltseinkommen <- as.numeric(as.character(
  bavaria$Haushaltseinkommen
))
bavaria$Studierende <- as.numeric(as.character(
  bavaria$Studierende
))
bavaria$Bevoelkerungsentwicklung <- as.numeric(
  as.character(bavaria$Bevoelkerungsentwicklung)
)
# load europe elevation raster
europe_raster <- raster("../datasets/elevation1x1_new.tif")
# load europe shapefiles
europe_shape <- read_sf("../datasets/ne_50m_admin_0_countries/ne_50m_admin_0_countries.shp")
europe_shape <- europe_shape[europe_shape$CONTINENT == "Europe",]
# cities above populaiton of 1 million
cities <- world.cities[world.cities$pop >= 1000000, ]
cities <- cities %>% st_as_sf(coords = c("long", "lat"), crs = 4326) %>%
  st_cast("POINT")
cities <- st_intersection(cities, st_union(europe_shape))
europe_shape <- st_cast(europe_shape, "MULTILINESTRING")
gemeinden <- read_sf("../datasets/gmd_ex.shp")
rosenheim <- gemeinden[str_detect(gemeinden$BEZ_KRS, "Rosenheim"), ]

honey <- read_csv("../datasets/honeyproduction.csv")
abrev <- read_xlsx("../datasets/abbrev.xlsx")
```


# Statische Karten
Am häufigsten werden geographische Daten mit Hilfe von statischen Karten dargestellt, die als `.png` oder `.pdf` Datei abgespeichert werden können. Ursprünglich konnten in R nur auf diese Art Daten visualisiert werden, doch durch die Entwicklung neuer Pakete, allen voran **sp**, wurden neue Möglichkeiten zur Darstellung dieser Daten geschaffen. Doch trotz neuer Methoden wie interaktiven Karten sind statische Karten auch heute noch das Steckenpferd der Datenvisualisierung in R.

## tmap
Die schnellste Möglichkeit zur Erstellung von Karten in R ist die Verwendung der `plot()` Funktion, mit der Vektor- und Rasterdaten simplistisch dargestellt werden können. Durch die Verwendung mehrerer Argumente, wie beispielsweise `col`, können die Graphiken gestylt werden, um mehr Informationen zu übermitteln. Eine weitere Möglichkeit stellt das Paket **grid** dar, mit dem mehr Kontrolle möglich ist.
Ein Paket das speziell zur Illustration von Geodaten entwickelt wurde, ist **tmap**. Dieses hat eine kompakte Syntax, ähnlich der von **ggplot2**. Des Weiteren können statische Karten durch die Verwendung des Befehls `tmap_mode()` schnell in interaktive Karten umgewandelt werden und umgekehrt. Außerdem werden die meisten geographischen Klassen als input akzeptiert, im Vergleich zu anderen Paketen, auch `raster` Daten.

Wie bereits erwähnt ähnelt die Syntax von **tmap** der von **ggplot2**. Dies beinhaltet eine strikte Trennung zwischen den Daten und der Ästhetik. Zu Beginn wird `tm_shape()` ein Datensatz übergeben, gefolgt von ein oder mehreren Ebenen, die die Art der Darstellung definieren. Dazu zählen beispielhaft `tm_fill()` und `tm_dots()`, um Daten als Polygone beziehungsweise Punkte zu plotten. 
```{r, eval=FALSE}
tm_shape(bavaria) + tm_fill()
tm_shape(bavaria) + tm_borders()
tm_shape(bavaria) + tm_polygons()
```
```{r chunk1, echo=FALSE, fig.cap="Einfaches Beispiel", fig.align="center"}
bav_1 <- tm_shape(bavaria) +
  tm_fill()

bav_2 <- tm_shape(bavaria) +
  tm_borders()

bav_3 <- tm_shape(bavaria) +
  tm_polygons()
tmap_arrange(bav_1, bav_2, bav_3, ncol = 3)
```

Das hier übergebene Objekt `bavaria` hat die Klasse `sf` und stellt die einzelnen Städte und Landkreise Bayerns dar. `tm_fill()` füllt die einzelnen Polygone, wodurch ein gefüllter Grundriss Bayerns entsteht . `tm_borders()` zeichnet die Grenzen der einzelnen Polygone und `tm_polygons()` vereint die beiden Funktionen und stellt beides gleichzeitig dar. Durch den `+` Operator können weitere Ebene hinzugefügt werden, mit denen verschiedene Arten von geographischen Daten visualisiert werden können.

## Karten Objekte
Mit **tmap** können Objekte nicht nur geplotted werden, sondern auch als Objekte der Klasse `"tmap"`.
```{r}
map_europe <- tm_shape(europe_raster) + tm_raster()
class(map_europe)

```
Das gespeicherte Objekt kann so einfach erweitert werden, oder zu einem späteren Zeitpunkt in der Konsole aufgerufen werden. Des Weiteren können zu dem Objekt weitere Ebenen mit `tm_shape()` hinzugefügt werden, wodurch mehrere Karten zu einer kombiniert werden können.
Im folgenden Codebeispiel wird auf dem obigen Code, der ein Höhenraster von Europa darstellt, aufgebaut. Dabei werden zunächst die Grenzlinien der einzelnen Staaten hinzugefügt, gefolgt von allen Städten mit über einer Million Einwohnern.
```{r}
map_europe2 <- map_europe + tm_shape(europe_shape) + tm_lines(alpha = 0.3)
map_europe3 <- map_europe2  + tm_shape(cities) + tm_dots(size = 0.3)
```
```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.align="center", fig.cap="Verwendung mehrerer Ebenen"}
map_europe3
```
Durch das Speichern der einzelnen Karten als Objekte können diese auch mit Hilfe der Funktion `tmap_arrange()` neben- oder übereinander dargestellt werden.
```{r, eval=FALSE}
tmap_arrange(bav_1, bav_2, bav_3, ncol = 3)
```
Der Nutzer ist nicht limitiert in der Anzahl an Ebenen, die er hinzufügen kann. Dabei sollte jedoch beachtet werden, dass bei zu vielen Informationen der Betrachter schnell überfordert sein kann.

## Ästhetik
Bei den bisherigen Plots wurden die Standard Einstellungen von **tmap** verwendet. Zur Gestaltung visuell ansprechender Karten können diese überschrieben werden. Dabei gibt es zwei Möglichkeiten:
    - Konstante Ästhetik
    - Ästhetik, die sich mit Variablenausprägung ändert
Im Vergleich zu **ggplot2** wird keine Helferfunktion (`aes()`) verwendet, um die Gestaltung der Karte zu individualisieren. Stattdessen werden die Argumente direkt übergeben. Zu den nützlichsten Argumenten zählt die Füllfarbe (`col`), die Transparenz (`alpha`), die Strichstärke (`lwd`) und die Linienart (`lty`).

```{r, fig.align="center",fig.cap="Verwendung verschiedener Argumente"}
bav1 <- tm_shape(bavaria) + tm_fill(col = "darkgreen")
bav2 <- tm_shape(bavaria) + tm_fill(col = "darkgreen", alpha = 0.5)
bav3 <- tm_shape(bavaria) + tm_polygons(col = "darkgreen", border.col = "orange")
bav4 <- tm_shape(bavaria) + tm_borders(lwd = 2)
bav5 <- tm_shape(bavaria) + tm_borders(lty = 4)
bav6 <- tm_shape(bavaria) + tm_polygons(col = "#E2E2E2", border.alpha = 0.5, lwd = 3)
tmap_arrange(bav1, bav1, bav3, bav4, bav5, bav6, ncol = 3)
```

Ein weiterer Unterschied zu **ggplot2** besteht darin, dass die Variablen Namen als character übergeben werden müssen und der `$` Operator somit nicht verwendet werden kann.
```{r, error=TRUE}
tm_shape(bavaria) + tm_polygons(col = bavaria$Bevoelkerungsentwicklung)
```

Die gewünschte Grafik wird mit folgendem Code erreicht:
```{r, eval=FALSE}
tm_shape(bavaria) + tm_polygons(col = "Bevoelkerungsentwicklung", midpoint = 0)
```
```{r, fig.align="center",fig.cap="Bevölkerungsentwicklung in Bayern von 2011 bis 2015", echo=FALSE}
tm_shape(bavaria) + tm_polygons(col = "Bevoelkerungsentwicklung",
                                midpoint = 0) +
  tm_layout(legend.outside = TRUE)
```

Das `midpoint` Argument wird hier verwendet, um den Wert 0 als natürlichen Mittelpunkt zu verwenden. In der resultierenden Karte ist zu erkennen, dass die Bevölkerung im Norden Bayerns zurückgeht, während vor allem um München herum die Bevölkerung stark ansteigt. 
```{r, echo=FALSE, fig.align="center", fig.cap = "Karte in base R"}
pal <- colorRampPalette(c("orange", "green"))
bavaria$order <- findInterval(bavaria$Bevoelkerungsentwicklung, sort(bavaria$Bevoelkerungsentwicklung))
plot(st_geometry(bavaria), col = pal(nrow(bavaria))[bavaria$order])  # works

```

Am Beispiel der letzten Karten ist zu sehen, dass **tmap** automatisch eine Farbpalette und Intervalle auswählt. Um andere Intervalle zu verwenden, kann entweder dem `breaks` Argument manuelle Grenzen übergeben werden oder mit `n` die Anzahl der bins festgelegt werden.
```{r, eval = FALSE}
tm_shape(bavaria) + tm_polygons(col = "Durchschnittsalter")
tm_shape(bavaria) + tm_polygons(col = "Durchschnittsalter", breaks = c(40, 42, 46, 54))
tm_shape(bavaria) + tm_polygons(col = "Durchschnittsalter", n = 3)
```
```{r, echo = FALSE, fig.align="center",fig.cap="Illustration des breaks und n Arguments"}
ba1 <- tm_shape(bavaria) + tm_polygons(col = "Durchschnittsalter")
ba2 <- tm_shape(bavaria) + tm_polygons(col = "Durchschnittsalter",
                                       breaks = c(40, 42, 46, 54))
ba3 <- tm_shape(bavaria) + tm_polygons(col = "Durchschnittsalter", n = 3)
tmap_arrange(ba1, ba2, ba3, ncol = 3)
```
Ein Alternative dazu ist das `style` Argument. Dadurch kann die Klassenbildung mit Hilfe von Algorithmen erfolgen. Unter anderem können folgende styles übergeben werden:

    - `style = pretty`: Rundet Intervallgrenzen zu ganzen Nummern. Ist die Standardeinstellung
    - `style = equal`: Teilt die Variable in Intervalle von gleicher Länge auf.
       Sollte nur benutzt werden, wenn die Variable gleichverteilt ist.
    - `style = quantile`: Teilt die Variable in Quantile auf.
       Somit sind in jedem Intervall gleich viele Beobachtungen. 
    - `style = jenks`: Identifiziert Gruppen mit ähnlichen Werten und
       maximiert den Unterschied zwischen ihnen.
    - `style = cont`: Stellt viele Farben über eine kontinuierliche Palette dar.
    - `style = cat`: Färbt bei kategorialen Daten jede Kategorie individuell ein.

Weitere Möglichkeiten sind `cat`, `fixed`, `sd`, `kmeans`, `hclust`, `bclust`, und `fisher`.

```{r, fig.align="center",fig.cap="Arbeitslosenquote in Bayern und Verteilung von Städten und Landkreisen", echo = FALSE, fig.width= 8, fig.height= 8, warning=FALSE, message=FALSE}
ba4 <- tm_shape(bavaria) + tm_polygons(col = "Arbeitslosenquote", style = "pretty", title = "Aq") + tm_credits('style = "pretty"', size = 1) + tm_layout(inner.margins = 0.1)
ba5 <- tm_shape(bavaria) + tm_polygons(col = "Arbeitslosenquote", style = "equal", title = "Aq") + tm_credits('style = "equal"', size = 1) + tm_layout(inner.margins = 0.1)
ba6 <- tm_shape(bavaria) + tm_polygons(col = "Arbeitslosenquote", style = "quantile", title = "Aq") + tm_credits('style = "quantile"', size = 1) + tm_layout(inner.margins = 0.1)
ba7 <- tm_shape(bavaria) + tm_polygons(col = "Arbeitslosenquote", style = "jenks", title = "Aq") + tm_credits('style = "jenks"', size = 1) + tm_layout(inner.margins = 0.1)
ba8 <- tm_shape(bavaria) + tm_polygons(col = "Arbeitslosenquote", style = "cont", title = "Aq") + tm_credits('style = "cont"', size = 1) + tm_layout(inner.margins = 0.1)
ba9 <- tm_shape(bavaria) + tm_polygons(col = "Art", style = "cat") + tm_credits('style = "cat"', size = 1) + tm_layout(inner.margins = 0.1)
tmap_arrange(ba4, ba5, ba6, ba7, ba8, ba9, ncol = 3)
```

Eine letzte Möglichkeit, um das Aussehen einer Karte zu beeinflussen, besteht in der Farbwahl der einzelnen Klassen. Der Nutzer kann dies über das Argument `palette`. Diesem kann der Name einer Palette aus dem **RColorBrewer** oder **Viridis** Paket übergeben werden. Soll die Reihenfolge der Palette umgedreht werden, kann zu Beginn des characters ein `-` hinzugefügt werden.
```{r, eval = FALSE}
tm_shape(bavaria) + tm_polygons(col = "Arbeitslosenquote", palette = "viridis")
tm_shape(bavaria) + tm_polygons(col = "Arbeitslosenquote", palette = "-viridis")
```
```{r, fig.align="center",fig.cap="Umdrehen einer Palette", echo = FALSE, warning=FALSE, message=FALSE}
b1 <- tm_shape(bavaria) + tm_polygons(col = "Arbeitslosenquote", palette = "viridis")
b2 <- tm_shape(bavaria) + tm_polygons(col = "Arbeitslosenquote", palette = "-viridis")
tmap_arrange(b1, b2, ncol = 2)
```
Bei den Paletten aus den beiden Paketen kann zwischen drei Arten von Paletten unterschieden werden:
    - Sequentielle Paletten: Folgen einem Farbverlauf von hell zu dunkel. Sollten für stetige Variablen verwendet werden. 
    - Divergierende Paletten: Folgen einem Farbverlauf von dunkel zu hell, zu dunkel. Sollten für stetige Variablen mit einem natürlichen Mittelpunkt (`midpoint`) verwendet werden.
    - Kategoriale Paletten: Leicht unterscheidbare Farben, ideal für kategoriale Daten.
Alternativ kann auch eine eigene Palette übergeben werden, hierfür könnten HEX-Codes verwendet werden.
Bei der Farbwahl sollte auf weiteres geachtet werden: Farben übertragen Gefühle. Beispielhaft wird rot mit negativen Sachen assoziiert, während grün mit positiven Dingen in Verbindung gebracht wird. Dieses Beispiel kann auch auf geographische Merkmale erweitert werden. Grün steht für Wälder und blau für Gewässer. Außerdem sollte bei Verwendung eine Palette klar sein, welche Farbe für niedrigere beziehungsweise höhere Werte steht. Damit eine möglichst breite Masse an Menschen eine Karte interpretieren kann, sollte wenn möglich auch darauf geachtet werden, dass farbenblinde Menschen die Unterschiede zwischen den Klassen identifizieren können.
```{r, fig.align="center",fig.cap="Sequentielle, divergierende und kategoriale Palette", echo=FALSE}
image_read("../datasets/palette.png")
```

## Layouts
Außer der Möglichkeit, die Karte an sich zu verändern, existiert die Möglichkeit andere Elemente der Grafik zu editieren. Mit Hilfe von Funktionen wie `tm_compass()`, `tm_scale_bar()`, `tm_logo()`, `tm_style()` und `tm_layout` lassen sich   Karten um die verschiedensten Elemente erweitern. Mit Hilfe der ersten drei dieser Funktion lassen sich ein Kompass, eine Maßstabsleiste und Bilder hinzufügen.
```{r, eval=FALSE, warning=FALSE}
tm_shape(bavaria) +
  tm_polygons(col = "Art", pal = c("white", "skyblue")) +
  tm_logo("../datasets/bavaria.png", height = 2) +
  tm_scale_bar(position = c("left", "bottom"), width = 0.15) +
  tm_compass(position = c("left", "top"), size = 2)
```

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.align="center", fig.cap="Bayernkarte mit zusätzlichen Elementen"}
tm_shape(bavaria) + tm_polygons(col = "Art", pal = c("white", "skyblue")) +
  tm_logo("../datasets/bavaria.png", height = 2) + tm_scale_bar(position = c("left", "bottom"), width = 0.15) +
  tm_compass(position = c("left", "top"), size = 2)

```

Mit Hilfe von `tm_layout()` kann eine Vielzahl an Eigenschaften der Karten geändert werden. So kann ein Titel oder eine Hintergrundfarbe hinzugefügt werden, die Skalierung geändert werden oder der Rahmen und die Legende entfernt werden.
```{r, eval = FALSE}
tm_shape(bavaria) + tm_polygons()
    + tm_layout(title = "Bayern", bg.color = "#228B22")
tm_shape(bavaria) + tm_polygons()
    + tm_layout(scale = 3, frame = FALSE)
tm_shape(bavaria) + tm_polygons(col = "Art")
    + tm_layout(frame.lwd = 3, legend.position = c("left", "bottom"))
tm_shape(bavaria) + tm_polygons(col = "Art") +
      tm_layout(inner.margins = 0.2, legend.show = FALSE)
```

```{r, echo=FALSE, fig.align="center", fig.cap="Einige Layout Einstellungen"}
l1 <- tm_shape(bavaria) + tm_polygons() + tm_layout(title = "Bayern", bg.color = "#228B22")
l2 <- tm_shape(bavaria) + tm_polygons() + tm_layout(scale = 3, frame = FALSE)
l3 <- tm_shape(bavaria) + tm_polygons(col = "Art") + tm_layout(frame.lwd = 3, legend.position = c("left", "bottom"))
l4 <- tm_shape(bavaria) + tm_polygons(col = "Art") + tm_layout(inner.margins = 0.2, legend.show = FALSE)
tmap_arrange(l1, l2, l3, l4, ncol = 2)
```

Außerdem können Schriftart und -größe geändert werden, sowie mit Hilfe visueller Filter, beispielsweise Sepia oder Schwarz-Weiß, das Aussehen weiter angepasst werden.
Durch Verwendung von `tm_style()` können vordefinierte Stile verwendet werden, um Karten zum Beispiel einen Old-School-Look zu geben oder sie für Farbenblinde zu optimieren. Einen Überblick über die verfügbaren Stile bietet die Funktion `tmap_style_catalog()`, die im aktuellen Arbeitsverzeichnis einen Ordner anlegt, der verschiedene Karten enthält.
```{r, eval=FALSE}
tm_shape(bavaria) + tm_polygons(col = "Art") + tm_style("classic")
tm_shape(bavaria) + tm_polygons(col = "Art") + tm_style("col_blind")
```
```{r, echo=FALSE, fig.align="center", fig.cap="Klassicher und farbenblinder Stil"}
a1 <- tm_shape(bavaria) + tm_polygons(col = "Art") + tm_style("classic")
a2 <- tm_shape(bavaria) + tm_polygons(col = "Art") + tm_style("col_blind")
tmap_arrange(a1, a2, ncol = 2)
```


## Inset maps
Manchmal können nicht alle Informationen effektiv mit nur einer Karte dargestellt werden, beispielsweise um zusätzliche Informationen zu übermitteln. Mit Hilfe der `print()` und `viewport()` Funktionen können mehrere kleinere Karten zu einer großen zusammengefügt werden. In dem nachfolgenden Beispiel sind die Städte und Gemeinden des Landkreises Rosenheim dargestellt. Da möglicherweise nicht alle Betrachter wissen, wo sich der Landkreis befindet, wird noch eine Bayern Karte mit einer bounding box um den Landkreis herum hinzugefügt.
```{r, message=FALSE, echo=FALSE}
bbox <- st_bbox(rosenheim, crs = 4326) %>% 
  st_as_sfc()
map_rosenheim <- tm_shape(rosenheim) + tm_polygons()
bayern <- tm_shape(bavaria) + tm_polygons() + tm_shape(bbox) + tm_polygons(alpha = 0, border.col = "red", lwd = 3)
```
```{r, include=TRUE, echo=TRUE, fig.align="center", fig.cap="Städte und Gemeinden des Landkreis Rosenheim"}
map_rosenheim
print(bayern, vp = grid::viewport(0.8, 0.185, width = 0.2, height = 0.45))
```

Ein weiteres Anwendungsgebiet dieser Art von Karten ist die Darstellung von Regionen, die weit voneinander entfernt sind. Im folgenden Beispiel werden alle 50 Staaten der USA in einer Grafik dargestellt, unter Berücksichtigung der Größen der einzelnen Staaten. Da Hawaii und Alaska zu weit von den restlichen 48 Staaten entfernt sind, wäre eine einzelne Karte nicht die beste Lösung, weswegen drei Karten erstellt und zusammengefügt werden.
Zuerst wird die Projektion der 48 Staaten in eine equal area projection geändert, die anderen beiden Datensätze haben diese bereits.

```{r}
us_states2163 <- st_transform(us_states, 2163)
```
Um die Karten möglichst getreu ihrer Größe darzustellen, wird für jede der drei Karten die Differenz zwischen dem größten und kleinsten y-Wert berechnet. Dafür werden bounding boxes verwendet. Anschließend werden die Faktoren berechnet, um die die Karten von Alaska und Hawaii größer beziehungsweise kleiner sind, als die der restlichen 48 Staaten.

```{r}
us_states_range <- st_bbox(us_states2163)[4] - st_bbox(us_states2163)[2]
hawaii_range <- st_bbox(hawaii)[4] - st_bbox(hawaii)[2]
alaska_range <- st_bbox(alaska)[4] - st_bbox(alaska)[2]
us_states_hawaii_ratio <- hawaii_range / us_states_range
us_states_alaska_ratio <- alaska_range / us_states_range
```

Anschließend werden die drei Karten erstellt. `legend.is.portrait = FALSE` sorgt dafür, dass die Legende horizontal angeordnet wird, anstatt von vertikal.

```{r}
us_states_map <- tm_shape(us_states2163) +
  tm_polygons(col = "total_pop_15",
              breaks = c(0, 5000000, 10000000,
                         15000000, 20000000,
                         25000000, 30000000,
                         35000000, 40000000),
              title = "Population 2015 in Millionen",
              pal = c("#E1F5C4", "#EDE574", "#F9D423", "#FC913A", "#FF4E50"),
              labels = c("0-5", "5-10", "10-15", "15-20", "20-25",
                         "25-30", "30-35", "35-40"),
              legend.is.portrait = FALSE) + 
  tm_layout(frame = FALSE,
            legend.outside = TRUE, legend.outside.position = "bottom")
hawaii_map <- tm_shape(hawaii) +
  tm_polygons(col = "total_pop_15",
              breaks = c(0, 5000000, 10000000,
                         15000000, 20000000,
                         25000000, 30000000,
                         35000000, 40000000),
              pal = c("#E1F5C4", "#EDE574", "#F9D423", "#FC913A", "#FF4E50")) + 
  tm_layout(title = "Hawaii", frame = FALSE, bg.color = NA,
            legend.show = FALSE, title.position = c("LEFT", "BOTTOM"))
alaska_map <- tm_shape(alaska) +
  tm_polygons(col = "total_pop_15",
              breaks = c(0, 5000000, 10000000,
                         15000000, 20000000,
                         25000000, 30000000,
                         35000000, 40000000),
              pal = c("#E1F5C4", "#EDE574", "#F9D423", "#FC913A", "#FF4E50")) + 
  tm_layout(title = "Alaska", frame = FALSE, bg.color = NA, legend.show = FALSE,
            title.position = c("LEFT", "TOP"))
```

Mit `grid.layout` wird ein Fenster mit zwei Reihen und einer Spalte definiert. Die Höhe der einzelnen Reihen hängt vom Verhältnis der "Höhe" von Alaska und den 48 Staaten ab. Danach werden die drei Karten eingefügt, bei Hawaii hängt die "Höhe" wieder vom Verhältnis zu den 48 Staaten ab. Mit `grid.lines` werden noch Linien hinzugefügt um die Karten besser voneinander abzutrennen.

```{r, fig.align="center",fig.cap="Einwohnerzahlen der Bundesstaaten in den USA"}
pushViewport(viewport(
  layout =
    grid.layout(2, 1,
                heights = unit(c(us_states_alaska_ratio, 1), "null")
                )
  ))
print(alaska_map, vp = viewport(layout.pos.row = 1))
print(us_states_map, vp = viewport(layout.pos.row = 2))
print(hawaii_map, vp = viewport(x = 0.1, y = 0.07,
                                height = us_states_hawaii_ratio / sum(c(us_states_alaska_ratio, 1))))
grid.lines(x = c(0, 1), y = c(0.58, 0.58), gp = gpar(lty = 2))
grid.lines(x = c(0, 0.2), y = c(0.33, 0), gp = gpar(lty = 2))
```

## Facettierte und animierte Karten
Neben der Möglichkeit verschiedene Elemente der Karten basierend auf einer Variable zu ändern, können Karten basierend auf einer Variable in mehrere Karten unterteilt werden. Was in **ggplot2** mit `facet_wrap()` gemacht wird, wird in **tmap** mit `tm_facets()` erledigt. Soll eine zeitliche Variable dargestellt werden, geht dies schlecht mit einer Karte, da sich die Geometrien häufig überlappen würden. Besonders in diesen Fällen ist die Verwendung facettierter Karten sinnvoll. Die Funktion hat fünf wichtige Argumente:

    - `by`: Nach welcher Variable soll aufgeteilt werden?
    - `nrow / ncol`: Die Anzahl der Zeilen beziehungsweise Spalten der Facetten
    - `free.cords`: Soll jede einzelne Karte ein eigenes Koordinatensystem haben?
    - `along`: Nach welcher Variable soll animiert werden?
    
```{r, include=FALSE}
honey0912 <- honey[honey$year > 2008, ]
honey0912 <- rbind(
  honey0912,
  matrix(NA, ncol = ncol(honey0912),
         nrow = 4 * length(unique(abrev$state)[!unique(abrev$state) %in% unique(honey0912$state)]),
         dimnames = list(
           c(seq_len(4 * length(unique(abrev$state)[!unique(abrev$state) %in% unique(honey0912$state)]))),
           colnames(honey0912)
         )
  )
)
honey0912$state <- as.character(honey0912$state)
honey0912[is.na(honey0912$state), ]$state <- sort(rep(unique(abrev$state)[!unique(abrev$state) %in% unique(honey0912$state)], 4))
honey0912[is.na(honey0912$year), ]$year <- rep(2009:2012, 10)
honey0912 <-  merge.data.frame(honey0912, abrev, by = "state")
colnames(honey0912)[c(1, 9)] <- c("short", "State")
us_states$State <- us_states$NAME
us_states <- us_states[us_states$NAME != "District of Columbia", ]
honey0912 <- merge(honey0912, us_states[, 7:8], by = "State", all.y = TRUE)
honey0912 <- st_as_sf(honey0912)
```
```{r, fig.align="center", fig.caption="Kosten eines Pfunds Honig in den USA", message=FALSE}
tm_shape(honey0912) + tm_polygons(col = "priceperlb", style = "cont",
                                  pal = viridis(10, direction = -1),
                                  title = "Price in US$ per lb") +
  tm_facets(by = "year", ncol = 2) +
  tm_layout(legend.outside.size = 0.2)
```

Ein Problem dieser Art von Karten ist, dass mit mehr Ausprägungen einer Variable mehr Karten erstellt werden, wodurch es schnell unübersichtlich wird und Unterschiede zwischen den einzelnen Karten nur noch sehr schwer zu erkennen sind. Dieses Problem wird von animierten Karten gelöst. In Papern können diese nicht dargestellt werden, allerdings werden heutzutage immer mehr Informationen online abgerufen, was dieses Problem mindert. Der Autor eines Artikels kann alternativ auch einen Link zu der animierten Karte in seinen Text einbauen. Wie bereits erwähnt, kann mit dem Argument `along` der Funktion `tm_facets()` eine animierte Karte erstellt werden. Mit Hilfe der Funktion `tmap_animation()` kann die erstellte Animation als GIF Datei abgespeichert werden, allerdings wird dafür die Software **ImageMagick** benötigt. Diese kann mit Hilfe des **installr** Pakets installiert werden.  (`installr::install.imagemagick()`) Die folgende Animation stellt ebenfalls den durchschnittlichen Preis eines Pfunds Honing in US$ dar, dieses Mal über einen Zeitraum von 15 Jahren. Mittels `delay` kann angegeben werden, wieviele Millisekunden zwischen den einzelnen Bildern vergehen sollen. Mit `width` und `height` können noch die Maße in Pixel angegeben werden, mit `loop`, ob das GIF eine Endlosschleife ist, oder nach einer bestimmten Anzahl an Runden endet.

```{r, include = FALSE, eval=FALSE}
tab <- table(honey$state)
no_rows <- sum(15 - tab[tab < 15])
new_mat <- matrix(NA, nrow = no_rows, ncol = 8)
colnames(new_mat) <- colnames(honey)
new_mat <- as.data.frame(new_mat)
new_mat$state <- unlist(lapply(seq_len(length(tab[tab < 15])),
                               function(x) {
                                 rep(names(tab[tab < 15])[x], 15 - tab[tab < 15][x])
                                 }
                               )
                        )
new_mat$year <- unlist(lapply(seq_len(length(tab[tab < 15])), function(x, ...) {
  years <- honey[honey$state == names(tab[tab < 15])[x], ]$year
  all <- 1998:2012
  all[!all %in% years]
}))
honey <- rbind(honey, new_mat)
honey <- rbind(
  honey,
  matrix(NA, ncol = ncol(honey),
         nrow = 15 * length(unique(abrev$state)[!unique(abrev$state) %in% unique(honey$state)]),
         dimnames = list(
           c(seq_len(15 * length(unique(abrev$state)[!unique(abrev$state) %in% unique(honey$state)]))),
           colnames(honey)
         )
  )
)
honey$state <- as.character(honey$state)
honey[is.na(honey$state), ]$state <- sort(rep(unique(abrev$state)[!unique(abrev$state) %in% unique(honey$state)], 15))
honey[is.na(honey$year), ]$year <- rep(1998:2012, 6)
honey <-  merge.data.frame(honey, abrev, by = "state")
colnames(honey)[c(1, 9)] <- c("short", "State")
us_states$State <- us_states$NAME
us_states <- us_states[us_states$NAME != "District of Columbia", ]
honey <- merge(honey, us_states[, 7:8], by = "State", all.y = TRUE)
honey <- st_as_sf(honey)
honey <- st_transform(honey, 4326)
write_sf(honey, "../datasets/honey.shp")
```
```{r, eval = FALSE}
honey <- read_sf("../datasets/honey.shp")
colnames(honey)[3:8] <- c("Number_of_colonies", "Yield_per_colony",
                          "Total_production", "Stocks","Price_per_lb",
                          "Value_of_production"
                          )
honey_animation <- tm_shape(honey) + tm_polygons(col = "Price_per_lb", style = "cont",
                                  pal = viridis(10, direction = -1)) +
  tm_facets(along = "year") +
  tm_layout(legend.position = c("left", "bottom"))
tmap_animation(honey_animation, filename = "honey.gif", delay = 50, width = 1181, height = 500)
```
```{r, fig.align="center",fig.cap="Animierte Karte", echo=FALSE}
image_resize(image_read("../datasets/honey.gif"), "700x1181")
```

## Weiterführende Links
Für mehr Informationen zu der Verwendung von **tmap** siehe https://geocompr.robinlovelace.net/adv-map.html. [@lovelace2019geocomputation]