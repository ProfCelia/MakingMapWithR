[
["intro.html", "Making maps with R 1 Intro", " Making maps with R Nico Hahn 2019-08-17 1 Intro Eine der wichtigsten Aspekte bei der Arbeit mit geographischen Daten ist die Darstellung und Kommunikation der Resultate. Diese sollten mÃ¶glichst kreativ sein, ohne an IntuitivitÃ¤t zu verlieren. Am hÃ¤ufigsten wird dabei auch statische Karten zurÃ¼ckgegriffen, wofÃ¼r in R beispielsweise die Funktion plot() verwendet werden kann. Ein bessere MÃ¶lichkeit ist jedoch, auf Pakete zurÃ¼ckzugreifen, die speziell entwickelt wurden um geograhische Daten zu visualisieren. Ein solches Pakete ist tmap, das im folgenden Kapitel behandelt wird. "],
["statische-karten.html", "2 Statische Karten 2.1 tmap 2.2 Karten Objekte 2.3 Ã„sthetik 2.4 Layouts 2.5 Inset maps 2.6 Facettierte und animierte Karten", " 2 Statische Karten Am hÃ¤ufigsten werden geographische Daten mit Hilfe von statischen Karten dargestellt, die als .png oder .pdf Datei abgespeichert werden kÃ¶nnen. UrsprÃ¼nglich konnten in R nur auf diese Art Daten visualisiert werden, doch durch die Entwicklung neuer Pakete, allen voran sp, wurden neue MÃ¶glichkeiten zur Darstellung dieser Daten geschaffen. Doch trotz neuen Methoden wie interaktiven Karten sind statische Karten auch heute noch das Steckenpferd der Datenvisualisierung in R. 2.1 tmap Die schnellste MÃ¶glichkeit zur Erstellung von Karten in R ist die Verwendung der plot() Funktion, mit der Vektor- und Rasterdaten simplistisch dargestellt werden kÃ¶nnen. Durch die Verwendung mehrerer Argumente, wie beispielsweise col, kÃ¶nnen die Graphiken gestylt werden, um mehr Informationen zu Ã¼bermitteln. Eine weitere MÃ¶glichkeit stellt das Paket grid dar, mit dem mehr Kontrolle mÃ¶glich ist. Ein Paket, dass speziell zur Illustration von Geodaten entwickelt wurde, ist tmap. Dieses hat eine kompakte Syntax, Ã¤hnlich der von ggplot2. Des weiteren kÃ¶nnen statische Karten durch die Verwendung des Befehls tmap_mode() schnell in interaktive Karten umgewandelt werden und umgekehrt. AuÃŸerdem werden die meiÃŸten geographischen Klassen als input akzeptiert, im Vergleich zu anderen Paketen, auch raster Daten. Wie bereits erwÃ¤hnt Ã¤hnelt die Syntax von tmap der von ggplot2. Dies beinhaltet eine strikte Trennung zwischen den Daten und der Ã„sthetik. Zu Beginn wird tm_shape() ein Datensatz Ã¼bergeben, gefolgt von ein oder mehreren Ebene, die die Art der Darstellung definieren. Dazu zÃ¤hlen beispielhaft tm_fill() und tm_dots() um Daten als Polygone beziehungsweise Punkte zu plotten. tm_shape(bavaria) + tm_fill() tm_shape(bavaria) + tm_borders() tm_shape(bavaria) + tm_polygons() Figure 2.1: Einfaches Beispiel Das hier Ã¼bergebene Objekt bavaria hat die Klasse sf und stellt die einzelnen StÃ¤dte und Landkreis Bayerns dar. tm_fill() fÃ¼llt die einzelnen Polygone, wodurch ein gefÃ¼llter Grundriss Bayerns entsteht . tm_borders() zeichnet die Grenzen der einzelnen Polygone und tm_polygons() vereint die beiden Funktionen und stellt beides gleichzeitig dar. Durch den + Operator kÃ¶nnen weitere Ebene hinzugefÃ¼gt werden, mit denen verschiedene Arten von geographischen Daten visualisiert werden kÃ¶nnen. 2.2 Karten Objekte Mit tmap kÃ¶nnen Objekte nicht nur geplotted werden, sondern auch als Objekte der Klasse &quot;tmap&quot;. map_europe &lt;- tm_shape(europe_raster) + tm_raster() class(map_europe) ## [1] &quot;tmap&quot; Das gespeicherte Objekte kann so einfach erweitert werden, oder zu einem spÃ¤teren Zeitpunkt in der Konsole aufgerufen werden. Des weiteren kÃ¶nnen zu dem Objekt weitere Ebenen mit tm_shape() hinzugefÃ¼gt werden, wodurch mehrere Karten zu einer kombiniert werden kÃ¶nnen. Im folgenden Codebeispiel wird auf dem obigen Code, der ein HÃ¶henraster von Europa darstellt, aufgebaut. Dabei werden zunÃ¤chst die Grenzlinien der einzelnen Staaten hinzugefÃ¼gt, gefolgt von allen StÃ¤dten mit Ã¼ber einer Millionen Einwohnern. map_europe2 &lt;- map_europe + tm_shape(europe_shape) + tm_lines(alpha = 0.3) map_europe3 &lt;- map_europe2 + tm_shape(cities) + tm_dots(size = 0.3) Figure 2.2: Verwendung mehrerer Ebenen Durch das speichern der einzelnen Karten als Objekte kÃ¶nnen diese auch mit Hilfe der Funktion tmap_arrange() neben- oder Ã¼bereinander dargestellt werden. Grafik wurde durch diesen Befehl erstellt. tmap_arrange(bav_1, bav_2, bav_3, ncol = 3) Der Nutzer ist nicht limitiert in der Anzahl an Ebenen, die er hinzufÃ¼gen kann. Dabei sollte jedoch beachtet werden, dass bei zu viel Informationen der Betrachter schnell Ã¼berfordert sein kann. 2.3 Ã„sthetik Bei den bisherigen Plots wurden die Standard Einstellungen von tmap verwendet. Zur Gestaltung visuell ansprechender Karten, kÃ¶nnen diese Ã¼berschrieben werden. Dabei gibt es zwei MÃ¶glichkeiten: - Konstante Ã„sthetik - Ã„sthetik die sich mit VariablenausprÃ¤gung Ã¤ndert Im Vergleich zu ggplot2 wird keine Helferfunktion (aes()) verwendet, um die Gestaltung der Karte zu individualisieren. Stattdessen werden die Argumente direkt Ã¼bergeben. Zu den am hÃ¤ufigsten verwendeten Argumenten zÃ¤hlt die FÃ¼llfarbe (col), die Transparenz (alpha), die StrichstÃ¤rke (lwd) und die Linienart (lty). bav1 &lt;- tm_shape(bavaria) + tm_fill(col = &quot;darkgreen&quot;) bav2 &lt;- tm_shape(bavaria) + tm_fill(col = &quot;darkgreen&quot;, alpha = 0.5) bav3 &lt;- tm_shape(bavaria) + tm_polygons(col = &quot;darkgreen&quot;, border.col = &quot;orange&quot;) bav4 &lt;- tm_shape(bavaria) + tm_borders(lwd = 2) bav5 &lt;- tm_shape(bavaria) + tm_borders(lty = 4) bav6 &lt;- tm_shape(bavaria) + tm_polygons(col = &quot;#E2E2E2&quot;, border.alpha = 0.5, lwd = 3) tmap_arrange(bav1, bav1, bav3, bav4, bav5, bav6, ncol = 3) Figure 2.3: Verwendung verschiedener Argumente Ein weiterer Unterschied zu ggplot2 besteht darin, dass die Variablen Namen als character Ã¼bergeben werden mÃ¼ssen und der $ Operator somit nicht verwendet werden kann. tm_shape(bavaria) + tm_polygons(col = bavaria$Bevoelkerungsentwicklung) ## Error: Fill argument neither colors nor valid variable name(s) Die gewÃ¼nschte Grafik wird mit folgendem Code erreicht: tm_shape(bavaria) + tm_polygons(col = &quot;Bevoelkerungsentwicklung&quot;, midpoint = 0) Figure 2.4: BevÃ¶lkerungsentwicklung in Bayern von 2011 bis 2015 Das midpoint Argument wird hier verwendet, um den Wert 0 als natÃ¼rlichen Mittelpunkt zu verwenden. In der resultierenden Karte ist zu erkennen, dass die BevÃ¶lkerung im Norden Bayerns zurÃ¼ckgeht, wÃ¤hrend vor allem um MÃ¼nchen herum die BevÃ¶lkerung starkt ansteigt. Figure 2.5: Karte in base R Am Beispiel der letzten Karten ist zu sehen, dass tmap automatisch eine Farbpalette und Intervalle auswÃ¤hlt. Um andere Intervalle zu verwenden kann entweder dem breaks Argument manuelle Grenzen Ã¼bergeben werden oder mit n die Anzahl der bins festgelegt werden. tm_shape(bavaria) + tm_polygons(col = &quot;Durchschnittsalter&quot;) tm_shape(bavaria) + tm_polygons(col = &quot;Durchschnittsalter&quot;, breaks = c(40, 42, 46, 54)) tm_shape(bavaria) + tm_polygons(col = &quot;Durchschnittsalter&quot;, n = 3) Figure 2.6: Illustration des breaks und n Arguments Ein Alternative dazu ist das style Argument. Dadurch kann die Klassenbildung mit Hilfe von Algorithmen erfolgen. Unteranderem kÃ¶nnen folgende styles Ã¼bergeben werden: - style = pretty: Rundet Intervallgrenzen zu ganzen Nummern. Ist die Standardeinstellung - style = equal: Teilt die Variable in Intervalle von gleicher LÃ¤nge auf. Sollte nur benutzt werden, wenn die Variable gleichverteilt ist. - style = quantile: Teilt die Variable in Quantile auf. Somit sind in jedem Intervall gleich viele Beobachtungen. - style = jenks: Identifiziert Gruppen mit Ã¤hnlichen Werten und maximiert den Unterschied zwischen ihnen. - style = cont: Stellt viele Farben Ã¼ber eine kontinuerliche Palette dar. - style = cat: FÃ¤rbt bei kategorialen Daten jede Kategorie individuell ein. Weitere MÃ¶glichkeiten wÃ¤ren cat, fixed, sd, kmeans, hclust, bclust, und fisher. Figure 2.7: Arbeitslosenquote in Bayern und Verteilung von StÃ¤dten und Landkreisen Eine letzte MÃ¶glichkeit um das Aussehen einer Karte zu beeinflussen besteht in der Farbwahl der einzelnen Klassen. Der Nutzer kann Ã¼ber das Argument palette. Diesem kann der Name einer bekannte Palette aus dem RColorBrewer oder Viridis Paket Ã¼bergeben werden. Soll die Reihenfolge der Palette umgedreht werden, kann zu Beginn des characters ein - hinzugefÃ¼gt werden. tm_shape(bavaria) + tm_polygons(col = &quot;Arbeitslosenquote&quot;, palette = &quot;viridis&quot;) tm_shape(bavaria) + tm_polygons(col = &quot;Arbeitslosenquote&quot;, palette = &quot;-viridis&quot;) Figure 2.8: Umdrehen einer Palette Bei den Paletten aus den beiden Paketen kann zwischen drei Arten von Paletten unterschieden werden: - Sequentielle Paletten: Folgen einem Farbverlauf von hell zu dunkel. Sollten fÃ¼r stetige Variablen verwendet werden. - Divergierende Paletten: Folgen einem Farbverlauf von dunkel zu hell, zu dunkel. Sollten fÃ¼r stetige Variablen mit einem natÃ¼rlichen Mittelpunkt (midpoint) verwendet werden. - Kategoriale Paletten: Leicht zu unterscheidbare Farben, ideal fÃ¼r kategoriale Daten. Alternativ kann auch eine eigenene Palette Ã¼bergeben werden, hierfÃ¼r kÃ¶nnten HEX-Codes verwendet werden. Bei der Farbwahl sollte auf weiteres geachtet werden: Farben Ã¼bertragen GefÃ¼hle. Beispielhaft wird rot mit negativen Sachen assoziert, wÃ¤hrend grÃ¼n mit positiven Dingen in Verbindung gebracht wird. Dieses Beispiel kann auch auf geographische Merkmale erweitert werden. GrÃ¼n steht fÃ¼r WÃ¤lder und blau fÃ¼r GewÃ¤sser. AuÃŸerdem sollte bei Verwendung eine Palette klar sein, welche Farbe fÃ¼r niedrigere beziehungsweise hÃ¶here Werte steht. Damit eine mÃ¶glichst breite Masse an Menschen eine Karte interpretieren kann, sollte wenn mÃ¶glich auch darauf geachtet werden, dass farbenblinde Menschen die Unterschiede zwischen den Klassen identifizieren kÃ¶nnen. 2.4 Layouts AuÃŸer der MÃ¶glichkeit die Karte an sich zu verÃ¤ndern, existiert die MÃ¶glichkeit andere Elemente der Grafik zu editieren. Mit Hilfe von Funktionen wie tm_compass(), tm_scale_bar(), tm_logo(), tm_style() und tm_layout lassen sich Karten um die verschiedensten Elemente erweitern. Mit Hilfe der ersten drei dieser Funktion lassen sich ein Kompass, eine MaÃŸstabsleiste und Bilder hinzufÃ¼gen. tm_shape(bavaria) + tm_polygons(col = &quot;Art&quot;, pal = c(&quot;white&quot;, &quot;skyblue&quot;)) + tm_logo(&quot;bavaria.png&quot;, height = 2) + tm_scale_bar(position = c(&quot;left&quot;, &quot;bottom&quot;), width = 0.15) + tm_compass(position = c(&quot;left&quot;, &quot;top&quot;), size = 2) Figure 2.9: Bayernkarte mit zusÃ¤tzlichen Elementen Mit Hilfe von tm_layout() kann eine Vielzahl an Eigenschaften der Karten geÃ¤ndert werden. So kann ein Titel oder eine Hintergrundfarbe hinzugefÃ¼gt werden, die Skalierung geÃ¤ndert werden oder der Rahmen und die Legende entfernt werden. tm_shape(bavaria) + tm_polygons() + tm_layout(title = &quot;Bayern&quot;, bg.color = &quot;#228B22&quot;) tm_shape(bavaria) + tm_polygons() + tm_layout(scale = 3, frame = FALSE) tm_shape(bavaria) + tm_polygons(col = &quot;Art&quot;) + tm_layout(frame.lwd = 3, legend.position = c(&quot;left&quot;, &quot;bottom&quot;)) tm_shape(bavaria) + tm_polygons(col = &quot;Art&quot;) + tm_layout(inner.margins = 0.2, legend.show = FALSE) Figure 2.10: Einige Layout Einstellungen AuÃŸerdem kann Schriftart und -grÃ¶ÃŸe geÃ¤ndert werden, sowie mit Hilfe visueller Filter, beispielsweise Sepia oder Schwarz-WeiÃŸ, das Aussehen weiter angepasst werden. Durch Verwendung von tm_style() kÃ¶nnen vordefinierte Stile verwendet werden, um Karten zum Beispiel einen Old-School-Look zu geben oder sie fÃ¼r Farbenblinde zu optimieren. Einen ÃƒÂƒÃ‚Âœberblick Ã¼ber die verfÃ¼gbaren Stile bietet die Funktion tmap_style_catalog(), die im aktuellen Arbeitsverzeichnis einen Ordner anlegt, der verschiedene Karten enthÃ¤lt. tm_shape(bavaria) + tm_polygons(col = &quot;Art&quot;) + tm_style(&quot;classic&quot;) tm_shape(bavaria) + tm_polygons(col = &quot;Art&quot;) + tm_style(&quot;col_blind&quot;) Figure 2.11: Klassicher und farbenblinder Stil 2.5 Inset maps Manchmal kÃ¶nnen nicht alle Informationen effektiv mit nur einer Karte dargestellt werden, beispielsweise um zusÃ¤tzlichen Informationen zu Ã¼bermitteln. Mit Hilfe der print und viewport Funktionen kÃ¶nnen mehrere kleinere Karten zu einer groÃŸen hinzugefÃ¼gt werden. In dem nachfolgenden Beispiel sind die StÃ¤dte und Gemeinden des Landkreis Rosenheim dargestellt. Da mÃ¶glicherweise nicht alle Betrachter wissen, wo sich der Landkreis befindet, wird noch eine Bayern Karte mit einer Bounding Box um den Landkreis herum hinzugefÃ¼gt. map_rosenheim print(bayern, vp = grid::viewport(0.8, 0.185, width = 0.2, height = 0.45)) Figure 2.12: StÃ¤dte und Gemeinden des Landkreis Rosenheim Eine weiteres Anwendungsgebiete dieser Art von Karten ist die Darstellung von Regionen die weit voneinander entfernt sind. Im folgenden Beispiel werden alle 50 Staaten der USA in einer Grafik dargestellt, unter BerÃ¼cksichtigung der GrÃ¶ÃŸen der einzelnen Staaten. Da Hawaii und Alaska zu weit von den restlichen 48 Staaten entfernt sind, wÃ¤re eine einzelne Karte nicht die beste LÃ¶sung, weswegen drei Karten erstellt und zusammengefÃ¼gt werden. Zuerst wird die Projektion der 48 Staaten in eine equal are projection geÃ¤ndert, die anderen beiden DatensÃ¤tze haben diese bereits. us_states2163 &lt;- st_transform(us_states, 2163) Um die Karten mÃ¶glichst getreu ihrer GrÃ¶ÃŸe darzustellen, wird fÃ¼r jede der drei Karten die Differenz zwischen dem grÃ¶ÃŸten und kleinsten y-Wert berechnet. DafÃ¼r werden bounding boxes verwendet. AnschlieÃŸend werden die Faktoren berechnet, um die die Karten von Alaska und Hawaii grÃ¶ÃŸer beziehungsweise kleiner sind, als die der restlichen 48 Staaten. us_states_range &lt;- st_bbox(us_states2163)[4] - st_bbox(us_states2163)[2] hawaii_range &lt;- st_bbox(hawaii)[4] - st_bbox(hawaii)[2] alaska_range &lt;- st_bbox(alaska)[4] - st_bbox(alaska)[2] us_states_hawaii_ratio &lt;- hawaii_range / us_states_range us_states_alaska_ratio &lt;- alaska_range / us_states_range AnschlieÃŸend werden die drei Karten erstellt. legend.is.portrait = FALSE sorgt dafÃ¼r, dass die Legende horizontal angeordnet wird, anstatt von vertikal. MIT LEGENDE NICHT MEHR SKALIERT DUCK IT I HATE MY LIFE us_states_map &lt;- tm_shape(us_states2163) + tm_polygons(col = &quot;total_pop_15&quot;, breaks = c(0, 5000000, 10000000, 15000000, 20000000, 25000000, 30000000, 35000000, 40000000), title = &quot;Population 2015 in Millionen&quot;, pal = c(&quot;#E1F5C4&quot;, &quot;#EDE574&quot;, &quot;#F9D423&quot;, &quot;#FC913A&quot;, &quot;#FF4E50&quot;), labels = c(&quot;0-5&quot;, &quot;5-10&quot;, &quot;10-15&quot;, &quot;15-20&quot;, &quot;20-25&quot;, &quot;25-30&quot;, &quot;30-35&quot;, &quot;35-40&quot;), legend.is.portrait = FALSE) + tm_layout(frame = FALSE, legend.outside = TRUE, legend.outside.position = &quot;bottom&quot;) hawaii_map &lt;- tm_shape(hawaii) + tm_polygons(col = &quot;total_pop_15&quot;, breaks = c(0, 5000000, 10000000, 15000000, 20000000, 25000000, 30000000, 35000000, 40000000), pal = c(&quot;#E1F5C4&quot;, &quot;#EDE574&quot;, &quot;#F9D423&quot;, &quot;#FC913A&quot;, &quot;#FF4E50&quot;)) + tm_layout(title = &quot;Hawaii&quot;, frame = FALSE, bg.color = NA, legend.show = FALSE, title.position = c(&quot;LEFT&quot;, &quot;BOTTOM&quot;)) alaska_map &lt;- tm_shape(alaska) + tm_polygons(col = &quot;total_pop_15&quot;, breaks = c(0, 5000000, 10000000, 15000000, 20000000, 25000000, 30000000, 35000000, 40000000), pal = c(&quot;#E1F5C4&quot;, &quot;#EDE574&quot;, &quot;#F9D423&quot;, &quot;#FC913A&quot;, &quot;#FF4E50&quot;)) + tm_layout(title = &quot;Alaska&quot;, frame = FALSE, bg.color = NA, legend.show = FALSE, title.position = c(&quot;LEFT&quot;, &quot;TOP&quot;)) Mit grid.layout wird ein Fenster mit zwei Reihen und einer Spalte definiert. Die HÃ¶he der einzelnen Reihen hÃ¤ngt vom VerhÃ¤ltnis der “HÃ¶he” von Alaska und den 48 Staaten ab. Danach werden die drei Karten eingefÃ¼gt, bei Hawaii hÃ¤ngt die “HÃ¶he” wieder vom VerhÃ¤ltnis zu den 48 Staaten ab. Mit grid.lines werden noch Linien hinzugefÃ¼gt um die Karten besser voneinander abzutrennen. pushViewport(viewport( layout = grid.layout(2, 1, heights = unit(c(us_states_alaska_ratio, 1), &quot;null&quot;) ) )) print(alaska_map, vp = viewport(layout.pos.row = 1)) print(us_states_map, vp = viewport(layout.pos.row = 2)) print(hawaii_map, vp = viewport(x = 0.1, y = 0.07, height = us_states_hawaii_ratio / sum(c(us_states_alaska_ratio, 1)))) grid.lines(x = c(0, 1), y = c(0.58, 0.58), gp = gpar(lty = 2)) grid.lines(x = c(0, 0.2), y = c(0.33, 0), gp = gpar(lty = 2)) Figure 2.13: Einwohnerzahlen der Bundesstaaten in den USA 2.6 Facettierte und animierte Karten Neben der MÃ¶glichkeit verschiedene Elemente der Karten basierend auf einer Variablen zu Ã¤ndern, kÃ¶nnen Karten basierend auf einer Variable in mehrere Karten unterteilt werden. Was in ggplot2 mit facet_wrap() gemacht wird, wird in tmap mit tm_facets() erledigt. Soll eine zeitliche Variable dargestellt werden, geht dies schlecht mit einer Karten, da sich die Geometrien hÃ¤ufig Ã¼berlappen wÃ¼rden. Besonders in diesen FÃ¤llen ist die Verwendung facettierter Karten sinnvoll. Die Funktion hat fÃ¼nf wichtige Argumente: - by: Nach welcher Variable soll aufgeteilt werden? - nrow / ncol: Die Anzahl der Zeilen beziehungsweise Spalten der Facetten - free.cords: Soll jede einezlne Karte ein eigenes Koordinatensystem haben? - along: Soll anstatt von Facetten eine Animation erstellt werden? tm_shape(honey0912) + tm_polygons(col = &quot;priceperlb&quot;, style = &quot;cont&quot;, pal = viridis(10, direction = -1), title = &quot;Price in US$ per lb&quot;) + tm_facets(by = &quot;year&quot;, ncol = 2) + tm_layout(legend.outside.size = 0.2) Ein Problem dieser Art von Karten ist, dass mit mehr AusprÃ¤gungen einer Variable mehr Karten erstellt werden wodurch es schnell unÃ¼bersichtlich wird und Unterschiede zwischen den einzelnen Karten nur noch sehr schwer zu erkennen sind. Dieses Problem wird von animierten Karten gelÃ¶st. In Papern kÃ¶nnen diese nicht dargestellt werden, allerdings werden heutzutage immer mehr Informationen online abgerufen, was dieses Problem mindert. Der Autor eines Artikels kann alternativ auch einen Link zu der animierten Karten in seinen Text einbauen. Wie bereits erwÃ¤hnt kann mit dem Argument along = TRUE der Funktion tm_facets() eine animierte Karte erstellt werden. Mit Hilfe der Funktion tmap_animation() kann die erstellt Animation als GIF Datei abgespeichert werden, allerdings wird dafÃ¼r die Software ImageMagick benÃ¶tigt. Diese kann mit Hilfe des installr Pakets installiert werden. (installr::install.imagemagick()) Die folgende Animation stellt ebenfalls den durchschnittlichen Preis eines Pfunds Honing in US$ dar, dieses mal Ã¼ber einen Zeitraum von 15 Jahren. Mittels delay kann angegeben werden, wieviel Millisekunden zwischen den einzelnen Bildern vergehen sollen. Mit width und height kÃ¶nnen noch die MaÃŸe in Pixel angegeben werden, mit loop ob das GIF eine Endlosschleife ist oder nach einer bestimmten Anzahl an Runden endet. honey_animation &lt;- tm_shape(honey) + tm_polygons(col = &quot;priceperlb&quot;, style = &quot;cont&quot;, pal = viridis(10, direction = -1)) + tm_facets(by = &quot;year&quot;, along = TRUE) tmap_animation(honey_animation, filename = &quot;honey.gif&quot;, delay = 25) "],
["interaktive-karten.html", "3 Interaktive Karten", " 3 Interaktive Karten Ein Nachteil von statischen Karten ist, dass diese immer das selbe abbilden. Damit ist gemeint, es wird nur ein Bereich gezeigt und alle Informationen werden direkt dargestellt. Interaktive Karten verbessern normale Karten dahingegend, dass sie dem Betrachter die MÃ¶glichkeit geben das Aussehen der Karten zu beeinflussen und zusÃ¤tzliche Informationen bereitstellen kÃ¶nnen. Die am hÃ¤ufigsten vorkommende Art von InteraktivitÃ¤t ist das verschieben und zoomen der dargestellten Karte und das Anzeigen zusÃ¤tzlicher Informationen bei dem Klick auf einzelne geometrische Objekte. In tmap kann durch die Funktion tmap_mode(&quot;view&quot;) zu jeder Karte InteraktivitÃ¤t hinzugefÃ¼gt werden. Mit tmap_mode(&quot;plot&quot;) wird diese wieder entfernt. tmap_mode(&quot;view&quot;) ## tmap mode set to interactive viewing tm_shape(bavaria) + tm_polygons(col = &quot;Bevoelkerungsentwicklung&quot;, midpoint = 0) Alternativ kann die Karte auch durch tmap_leaflet() erstellt werden. Wie zu erkennen ist, kann bei der interaktiven Karten zwischen mehreren Hintergrundkarten gewÃ¤hlt werden. Um eine bestimmte Karten als Hintergrund zu verwenden, kann die Funktion tm_basemap() verwendet werden. tm_shape(bavaria) + tm_polygons(col = &quot;Bevoelkerungsentwicklung&quot;, midpoint = 0) + tm_basemap(&quot;Stamen.Watercolor&quot;) Alle Karten und deren Namen kÃ¶nnen unter dem folgenden Link betrachtet werden: https://leaflet-extras.github.io/leaflet-providers/preview/ Auch facettierte Karten kÃ¶nnen im interaktiven Modus dargestellt werden: tm_shape(bavaria) + tm_polygons(col = &quot;Arbeitslosenquote&quot;) + tm_facets(by = &quot;Art&quot;) Interaktive Karten sind auch gut geeignet, um sich einen ersten Ãœberblick Ã¼ber einen Datensatz zu verschaffen. In dem folgenden Beispiel werden UnfÃ¤lle in drei Londoner Stadtteilen in 2017 dargestellt. Zuerst wird der Datensatz geladen, UnfÃ¤lle aus dem Jahr 2017 ausgewÃ¤hlt und Daten ohne bekannten Standort entfernt. accidents &lt;- read.csv(&quot;datasets/Accident_Information.csv&quot;) accidents &lt;- accidents[accidents$Year == 2017, ] accidents &lt;- accidents[!is.na(accidents$Latitude), ] Als nÃ¤chstes wird der Datensatz in ein sf Objekt verwandelt. accidents &lt;- accidents %&gt;% st_as_sf(coords = c(&quot;Longitude&quot;, &quot;Latitude&quot;), crs = 4326) %&gt;% st_cast(&quot;POINT&quot;) Danach werden Londoner Shapefiles geladen und die Intersections zwischen den beiden DatensÃ¤tze gesucht. london &lt;- read_sf(&quot;datasets/London_Borough_Excluding_MHW.shp&quot;) %&gt;% st_transform(4326) london_union &lt;- st_union(london) accidents_m &lt;- st_intersects(london_union, accidents) accidents &lt;- accidents[unlist(accidents_m), ] Damit es nicht zu unÃ¼bersichtlich wird, werden nur drei Stadteile ausgewÃ¤hlt. london &lt;- london[london$NAME %in% c(&quot;City of London&quot;, &quot;Westminster&quot;, &quot;Camden&quot;), ] london &lt;- st_union(london) accidents_m &lt;- st_intersects(london, accidents) ## although coordinates are longitude/latitude, st_intersects assumes that they are planar accidents &lt;- accidents[unlist(accidents_m), ] Jetzt muss nur noch die Karte dargestellt werden. DafÃ¼r wird zuerst die Variable Light_Conditions fÃ¼r eine schÃ¶nere Legende sortiert, ehe die Karte geplotted wird. Jeder Punkt stellt einen Unfall dar und bei einem Klick darauf werden mehr Informationen dargestellt. # do some ordering for the legend accidents$Light_Conditions &lt;- ordered(accidents$Light_Conditions, levels = c( &quot;Daylight&quot;, &quot;Darkness - lights lit&quot;, &quot;Darkness - lighting unknown&quot;, &quot;Darkness - lights unlit&quot;, &quot;Darkness - no lighting&quot;, &quot;Data missing or out of range&quot; )) # define the map map_london &lt;- tm_shape(accidents) + tm_dots(group = &quot;2017&quot;, col = &quot;Light_Conditions&quot;, palette = &quot;Dark2&quot;, popup.vars = TRUE) + tm_view(alpha = 1, basemaps = &quot;Esri.WorldTopoMap&quot;) map_london "],
["karten-mit-shiny.html", "4 Karten mit Shiny", " 4 Karten mit Shiny Interaktive Karten können durch Popups deutlich mehr Informationen überliefern als statische Karten, doch auch sie haben ihre Limitationen: - Es gibt nur ein fixes User Interface - Es gibt Probleme bei der Darstellung großer Datensätze - Die Verknüpfung der Karten mit anderen Graphen ist nur schwer möglich. Eine Möglichkeit um diese Probleme anzugehen, stellen Web Apps dar. Das Grundprinzip einer Web App besteht aus zwei Teilen: 1. Das User Interface: Was sieht der Benutzer? Dies beinhaltet die Karte(n), Auswahlmöglichkeiten um die Karten zu gestalten, zusätzliche Grafiken, ... 2. Der Server: Auf dem Server findet die Berechnung basierend auf den Inputs aus dem User Interface statt. Diesen Teil sieht der Benutzer nicht. In R können diese Apps mit Hilfe des Pakets shiny entwickelt werden. Hierfür muss ein Skript mit Namen app.R erstellt werden, dass zwei Elemente enthält: ui und server. Alternativ können auch zwei Skripte ui.R und server.R erstellt werden. Im weiteren Verlauf wird von einem Skript, app.R, ausgegangen. Am Ende dieses Skript muss der Befehl shinyApp(ui = ui, server = server) stehen, damit die App gestartet werden kann. Ein einfaches Beispiel für eine App mit den Paketen shiny und leaflet könnte wie folgt aussehen: Zuerst werden die Paketen und der Bienen Datensatz aus Kapitel 2 geladen: library(leaflet) library(RColorBrewer) library(sf) library(shiny) library(stringr) honey &lt;- read_sf(&quot;honey.shp&quot;) colnames(honey)[3:8] &lt;- c(&quot;Number_of_colonies&quot;, &quot;Yield_per_colony&quot;, &quot;Total_production&quot;, &quot;Stocks&quot;,&quot;Price_per_lb&quot;, &quot;Value_of_production&quot; ) Als erstes wird das User Interface definiert: Es wird eine fluidPage erstellt, damit sich die App anpasst wenn das Fenster verkleinert oder vergrößert wird. Dann wird eine fluidRow hinzugefügt, in die drei column Elemente hinzugefügt werden, die jeweils einen selectInput enthalten. Eine column gibt an, wieviel Platz ein Element in der Breite einnimt. Dafür wird das Fenster in 12 Spalten unterteilt, 4 nimmt also ein Drittel der Seite ein. Ein selectInput entspricht einer Combobox, also ein Eingabefenster bei dem aus mehreren Vorschlägen ausgewählt werden kann. multiple = FALSE sorgt dafür, dass maximal ein Vorschlag ausgewählt werden kann. Nach der ersten fluidRow wird eine zweite hinzugefügt, die einen leafletOutput enthält, also die Karte auf der später alles dargestellt wird. ui &lt;- fluidPage( fluidRow( column( width = 4, selectInput( inputId = &quot;year&quot;, label = &quot;Select year:&quot;, choices = 1998:2012, multiple = FALSE ) ), column( width = 4, selectInput( inputId = &quot;variable&quot;, label = &quot;Select variable:&quot;, choices = colnames(honey)[3:8], multiple = FALSE ) ), column( width = 4, selectInput( inputId = &quot;palette&quot;, label = &quot;Select palette:&quot;, choices = c(&quot;YlOrRd&quot;, &quot;YlGnBu&quot;, &quot;BuPu&quot;, &quot;Oranges&quot;, &quot;Greys&quot;), multiple = FALSE ) ) ), fluidRow( leafletOutput( outputId = &quot;map&quot;, height = &quot;80vh&quot; ) ) ) Anschließend muss der Server definiert werden. outmap$map definiert was mit dem Objekt mit der outputId map geschehen soll. Die Funktion renderLeaflet wird verwendet, um eine Leaflet Karte zu rendern. Doch bevor die Karte gerendert werden kann, muss etwas Vorarbeit geleistet werden. Als erstes wird ein Teildatensatz erstellt, der alle Daten aus dem ausgewählten Jahr für die ausgewählte Variable enthält. Die von dem Benutzer ausgewählten Werte werden mit input$inputId abgerufen. In diesem Fall input$year, input$variable und input$palette. Diese haben immer die Klassen character, für das Jahr muss dieser Wert also in einen numerischen umgewandelt werden. Die Funktion colorNumeric wird für die Erstellung der Farbpalette verwendet, ehe ein Titel für die Legende erstellt wird und die Karte erstellt wird. Mehr zu der Erstellung der Karte und des Leaflet Pakets in dem nächsten Kapitel. server &lt;- function(input, output, session) { output$map &lt;- renderLeaflet({ honey_data &lt;- honey[honey$year == as.numeric(input$year), input$variable] pal &lt;- colorNumeric(brewer.pal(9, input$palette), st_drop_geometry(honey_data)) title &lt;- paste(str_replace_all(input$variable, &quot;\\\\_&quot;, &quot; &quot;), &quot;:&quot;, sep = &quot;&quot;) leaflet() %&gt;% addTiles() %&gt;% addPolygons(data = honey_data, color = ~pal(get(input$variable))) %&gt;% addLegend(data = honey_data, pal = pal, values = ~get(input$variable), title = title, opacity = 1, position = &quot;bottomleft&quot;, na.label = &quot;No data available&quot;) }) } Die resultierende App sieht wie folgt aus: "]
]
